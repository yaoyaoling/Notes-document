# UML统一建模语言

UML（Unified Modeling Language，统一建模语言）是用来设计软件蓝图的可视化建模语言，是一种为面向对象系统的产品进行说明、可视化和编制文档的标准语言，独立于任何一种具体的程序设计语言。

1997 年 UML 被国际对象管理组织（OMG）采纳为面向对象的建模语言的国际标准。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。

## 1.应用场景

UML 能为软件开发的所有阶段提供模型化和可视化支持。而且融入了软件工程领域的新思想、新方法和新技术，使软件设计人员沟通更简明，进一步缩短了设计时间，减少开发成本。

UML 具有很宽的应用领域。其中最常用的是建立软件系统的模型，但它同样可以用于描述非软件领域的系统，如机械系统、企业机构或业务过程，以及处理复杂数据的信息系统、具有实时要求的工业系统或工业过程等。总之，UML 可以对任何具有静态结构和动态行为的系统进行建模，而且使用于从需求规格描述直至系统完成后的测试和维护等系统开发的各个阶段。

UML 模型大多以图表的方式表现出来，一份典型的建模图表通常包含几个块或框、连接线和作为模型附加信息的文本。这些虽简单却非常重要，在 UML 规则中相互联系和扩展。

在这里大家可能会疑问，UML 明明是一种图形，为什么说是语言呢？

语言是包括文字和图形的，有很多内容文字是无法表达的。你见过建筑设计图纸吗？里面还不是很多图形，光用文字能表达清楚建筑设计吗？在建筑界，有一套标准来描述设计，同样道理，在软件开发界，我们也需要一套标准来帮助我们做好软件开发的工作。UML 就是其中的一种标准，注意这可不是唯一标准，只是 UML 是大家比较推崇的一种标准而已。UML 并不是强制性标准，没有规定在软件开发中一定要用 UML，但是我们需要包括 UML 在内的各种标准，来提高我们软件开发的水平。

## 2.基本构件

UML 建模的核心是模型，模型是现实的简化、真实系统的抽象。UML 提供了系统的设计蓝图。当给软件系统建模时，需要采用通用的符号语言，这种描述模型所使用的语言被称为建模语言。在 UML 中，所有的描述由事物、关系和图这些构件组成。下图完整地描述了所有构件的关系。

![image-20220424092120678](GOF 23种设计模式.assets\image-20220424092120678.png)

下面对上图中的构件进行说明。

## 3.事物

事物是抽象化的最终结果，分为结构事物、行为事物、分组事物和注释事物。

- **结构事物**

  结构事物是模型中的静态部分，用以呈现概念或实体的表现元素，如下表所示。

  

  | 事物                   | 解释                                                         | 图例                                                         |
  | ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | 类（Class）            | 具有相同属性、方法、关系和语义的对象集合                     | <img src="GOF 23种设计模式.assets\image-20220424092521298.png?lastModify=1650763300" alt="image-20220424092634845" style="zoom:67%;" /> |
  | 接口（Interface）      | 指一个类或构件的一个服务的操作集合，它仅仅定义了一组操作的规范，并没有给出这组操作的具体实现 | <img src="GOF 23种设计模式.assets\image-20220424092634845.png?lastModify=1650763300" alt="image-20220424092634845" style="zoom:67%;" /> |
  | 用例（User Case）      | 指对一组动作序列的描述，系统执行这些动作将产生一个对特定的参与者（Actor）有价值且可观察的结果 | <img src="GOF 23种设计模式.assets\image-20220424092733109.png?lastModify=1650763300" alt="image-20220424092733109" style="zoom: 67%;" /> |
  | 协作（Collaboration）  | 定义元素之间的相互作用                                       | ![image-20220424092923161](GOF 23种设计模式.assets\image-20220424092923161.png?lastModify=1650763300) |
  | 组件（Component）      | 描述物理系统的一部分                                         | <img src="GOF 23种设计模式.assets\image-20220424092902481.png?lastModify=1650763300" alt="image-20220424092902481" style="zoom:67%;" /> |
  | 活动类（Active Class） | 指对象有一个或多个进程或线程。活动类和类很相象，只是它的对象代表的元素的行为和其他元素是同时存在的 | <img src="GOF 23种设计模式.assets\image-20220424092833509.png?lastModify=1650763300" alt="image-20220424092833509" style="zoom:67%;" /> |
  | 节点（Node）           | 定义为运行时存在的物理元素                                   | <img src="GOF 23种设计模式.assets\image-20220424092811674.png?lastModify=1650763300" alt="image-20220424092811674" style="zoom:67%;" /> |

- **行为事物**

  行为事物指 UML 模型中的动态部分，如下表所示。

  | 事物                    | 解释                       | 用例                                                         |
  | ----------------------- | -------------------------- | ------------------------------------------------------------ |
  | 交互（Interaction）     | 包括一组元素之间的消息交换 | ![image-20220424093046923](GOF 23种设计模式.assets\image-20220424093046923.png?lastModify=1650763300) |
  | 状态机（State Machine） | 由一系列对象的状态组成     | ![image-20220424093033477](GOF 23种设计模式.assets\image-20220424093033477.png?lastModify=1650763300) |

- **分组事物**

  目前只有一种分组事物，即包。包纯碎是概念上的，只存在于开发阶段，结构事物、行为事物甚至分组事物都有可能放在一个包中，如下表所示。

  | 事物          | 解释                | 用例                                                         |
  | ------------- | ------------------- | ------------------------------------------------------------ |
  | 包（Package） | UML中唯一的组织机制 | ![image-20220424093006062](GOF 23种设计模式.assets\image-20220424093006062.png?lastModify=1650763300) |

- **注释事物**

  注释事物是解释 UML 模型元素的部分，如下表所示。

  | 事物         | 解释                  | 用例                                                         |
  | ------------ | --------------------- | ------------------------------------------------------------ |
  | 注释（Note） | 用于解析说明 UML 元素 | ![image-20220424093114034](GOF 23种设计模式.assets\image-20220424093114034.png?lastModify=1650763300) |

> 关于 UML 中的关系，我们在《[UML类图及类图之间的关系](http://c.biancheng.net/view/8374.html)》一节讲解。

## 4.图

UML2.0 一共有 13 种图（UML1.5 定义了 9 种，UML2.0 增加了 4 种），分别是类图、对象图、构件图、部署图、活动图、状态图、用例图、时序图、协作图 9 种，以及包图、组合结构图、时间图、交互概览图 4 种。

| 图名称                                      | 解释                                                         |
| ------------------------------------------- | ------------------------------------------------------------ |
| 类图（Class Diagrams）                      | 用于定义系统中的类                                           |
| 对象图（Object Diagrams）                   | 类图的一个实例，描述了系统在具体时间点上所包含的对象及各个对象之间的关系 |
| 构件图（Component Diagrams）                | 一种特殊的 UML 图，描述系统的静态实现视图                    |
| 部署图（Deployment Diagrams）               | 定义系统中软硬件的物理体系结构                               |
| 活动图（Activity Diagrams）                 | 用来描述满足用例要求所要进行的活动及活动间的约束关系         |
| 状态图（State Chart Diagrams）              | 用来描述类的对象的所有可能的状态和时间发生时，状态的转移条件 |
| 用例图（Usecase Diagrams）                  | 用来描述用户的需求，从用户的角度描述系统的功能，并指出各功能的执行者，强调谁在使用系统、系统为执行者完成哪些功能 |
| 时序图（Sequence Diagrams）                 | 描述对象之间的交互顺序，着重体现对象间消息传递的时间顺序，强调对象之间消息的发送顺序，同时显示对象之间的交互过程 |
| 协作图（Collaboration Diagrams）            | 描述对象之间的合作关系，更侧重向用户对象说明哪些对象有消息的传递 |
| 包图（Package Diagrams）                    | 对构成系统的模型元素进行分组整理的图                         |
| 组合结构图（Composite Structure Diagrams）  | 表示类或者构建内部结构的图                                   |
| 时间图（Timing Diagrams）                   | 用来显示随时间变化，一个或多个元素的值或状态的更改，也显示时间控制事件之间的交互及管理它们的时间和期限约束 |
| 交互概览图（Interaction Overview Diagrams） | 用活动图来表示多个交互之间的控制关系的图                     |



# UML类图及类图之间的关系

在 UML 2.0 的 13 种图中，类图（Class Diagrams）是使用频率最高的 UML 图之一。类图描述系统中的类，以及各个类之间的关系的静态视图，能够让我们在正确编写代码之前对系统有一个全面的认识。类图是一种模型类型，确切地说，是一种静态模型类型。类图表示类、接口和它们之间的协作关系，用于系统设计阶段。

## 1.类、接口和类图

- **类**

  类（Class）是指具有相同属性、方法和关系的对象的抽象，它封装了数据和行为，是面向对象程序设计（OOP）的基础，具有封装性、继承性和多态性等三大特性。在 UML 中，类使用包含类名、属性和操作且带有分隔线的矩形来表示。

  (1) 类名（Name）是一个字符串，例如，Student。

  (2) 属性（Attribute）是指类的特性，即类的成员变量。UML 按以下格式表示：

  ```c#
  [可见性]属性名:类型[=默认值]
  ```

  例如：-name:String

  注意：“可见性”表示该属性对类外的元素是否可见，包括公有（Public）、私有（Private）、受保护（Protected）和朋友（Friendly）4 种，在类图中分别用符号+、-、#、~表示。

  (3) 操作（Operations）是类的任意一个实例对象都可以使用的行为，是类的成员方法。UML 按以下格式表示：

  ```c#
  [可见性]名称(参数列表)[:返回类型]
  ```

  例如：+display():void。

  如下所示是学生类的 UML 表示。

  

  <img src="GOF 23种设计模式.assets\image-20220424094425757.png" alt="image-20220424094425757" style="zoom:80%;" />

  Student 类

  > 类图用 3 个矩形拼接表示，最上面的部分标识类的名称，中间的部分标识类的属性，最下面的部分标识类的方法。
  
  类图中，需注意以下几点：
  
  - 抽象类或抽象方法用斜体表示
  
  - 如果是接口，则在类名上方加 <<Interface>>
  
  - 字段和方法返回值的数据类型非必需
  
  - 静态类或静态方法加下划线
  
- **接口**

  接口（Interface）是一种特殊的类，它具有类的结构但不可被实例化，只可以被子类实现。它包含抽象操作，但不包含属性。它描述了类或组件对外可见的动作。在 UML 中，接口使用一个带有名称的小圆圈来进行表示。

  如下所示是图形类接口的 UML 表示。

  ![image-20220424100115188](GOF 23种设计模式.assets\image-20220424100115188.png)

  Graph 接口

- **类图**

  类图（ClassDiagram）是用来显示系统中的类、接口、协作以及它们之间的静态结构和关系的一种静态模型。它主要用于描述软件系统的结构化设计，帮助人们简化对软件系统的理解，它是系统分析与设计阶段的重要产物，也是系统编码与测试的重要模型依据。

  类图中的类可以通过某种编程语言直接实现。类图在软件系统开发的整个生命周期都是有效的，它是面向对象系统的建模中最常见的图。如下所示是“计算长方形和圆形的周长与面积”的类图，图形接口有计算面积和周长的抽象方法，长方形和圆形实现这两个方法供访问类调用。

  ![image-20220424100332849](GOF 23种设计模式.assets\image-20220424100332849.png)

  “计算长方形和圆形的周长与面积”的类图

## 2.类之间的关系

UML 将事物之间的联系归纳为 6 种，并用对应的图形类表示。下面根据类与类之间的耦合度从弱到强排列。UML 中的类图有以下几种关系：依赖关系、关联关系、聚合关系、组合关系、泛化关系和实现关系。其中泛化和实现的耦合度相等，它们是最强的。

- **依赖关系**

  依赖（Dependency）关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。

  在 UML 类图中，**依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类**。如下是人与手机的关系图，人通过手机的语音传送方法打电话。

![image-20220424100549986](GOF 23种设计模式.assets\image-20220424100549986.png)

- **关联关系**

  关联（Association）关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。

  关联可以是双向的，也可以是单向的。在 UML 类图中，**双向的关联可以用带两个箭头或者没有箭头的实线来表示，单向的关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类**。也可以在关联线的两端标注角色名，代表两种不同的角色。

  在代码中通常将一个类的对象作为另一个类的成员变量来实现关联关系。如下是老师和学生的关系图，每个老师可以教多个学生，每个学生也可向多个老师学，他们是双向关联。

![image-20220424100752054](GOF 23种设计模式.assets\image-20220424100752054.png)

- **聚合关系**

  聚合（Aggregation）关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，是 has-a 的关系。

  聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。

  在 UML 类图中，**聚合关系可以用带空心菱形的实线来表示，菱形指向整体。如下是大学和教师的关系图**。

![image-20220424100841891](GOF 23种设计模式.assets\image-20220424100841891.png)

- **组合关系**

  组合（Composition）关系也是关联关系的一种，也表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系，是 cxmtains-a 关系。

  在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。

  在 UML 类图中，**组合关系用带实心菱形的实线来表示，菱形指向整体**。如下是头和嘴的关系图。

![image-20220424101007580](GOF 23种设计模式.assets\image-20220424101007580.png)

- **泛化关系**

  泛化（Generalization）关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系，是 is-a 的关系。

  在 UML 类图中，**泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类**。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如下所示。

![image-20220424101042402](GOF 23种设计模式.assets\image-20220424101042402.png)

- **实现关系**

  实现（Realization）关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。

  在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如下所示。

![image-20220424101152480](GOF 23种设计模式.assets\image-20220424101152480.png)




# 类关系记忆技巧

类关系记忆技巧总结如下表所示。

| 分类                                                         | 箭头特征                                      | 记忆技巧                                                     |
| ------------------------------------------------------------ | --------------------------------------------- | ------------------------------------------------------------ |
| 箭头方向                                                     | 从子类指向父类                                | 定义子类需要通过 extends 关键字指定父类子类一定是知道父类定义的，但父类并不知道子类的定义只有知道对方信息时才能指向对方箭头的方向是从子类指向父类 |
| 继承/实现                                                    | 用线条连接两个类； 空心三角箭头表示继承或实现 | 实线表示继承，是is-a的关系，表示扩展，不虚，很结实           |
| 虚线表示实现，虚线代表“虚”无实体                             |                                               |                                                              |
| 关联/依赖                                                    | 用线条连接两个类； 普通箭头表示关联或依赖     | 虚线表示依赖关系：临时用一下，若即若离，虚无缥缈，若有若无表示一种使用关系，一个类需要借助另一个类来实现功能一般一个类将另一个类作为参数使用，或作为返回值 |
| 实线表示关联关系：关系稳定，实打实的关系，“铁哥们”表示一个类对象和另一个类对象有关联通常一个类中有另一个类对象作为属性 |                                               |                                                              |
| 组合/聚合                                                    | 用菱形表示：像一个盛东西的器皿（如盘子）      | 聚合：空心菱形，代表空器皿里可以放很多相同的东西，聚集在一起（箭头方向所指的类）整体和局部的关系，两者有独立的生命周期，是 has-a 的关系弱关系，消极的词：弱-空 |
| 组合：实心菱形，代表器皿里已经有实体结构的存在，生死与共整体与局部的关系，和聚合关系对比，关系更加强烈，两者具有相同的生命周期，contains-a 的关系强关系，积极的词；强-满 |                                               |                                                              |

注意：UML 的标准类关系图中，没有实心箭头。有些 Java 编程的 IDE 自带类生成工具可能出现实心箭头，主要目的是降低理解难度。

下面用一个经典案例来加深和巩固对类图的理解。下图是对动物衍生关系描述的类图。这个图非常有技术含量也非常经典，大家可以好好理解一下。

<img src="GOF 23种设计模式.assets\image-20220426211323546.png" alt="image-20220426211323546" style="zoom:80%;" />



# UMLet的使用与类图的设计

## 1.实验目的

本实验的主要目的如下。

- 理解类的基本概念，掌握如何从需求分析中抽象出类的方法。
- 理解类之间关系，掌握如何分析具体实例中的类之间的关系。
- 掌握在 UMLet 中绘制类图的基本操作方法。

## 2.实验原理

在绘制类图之前，我们先来介绍一下 UMLet 工具。

**UMLet的使用**

UMLet 是一款免费且开源的 UML 建模工具，它可以将原型导出为 bmp、eps、gif、jpg、pdf、png、svg 等格式，还可以集成到 Eclipse 中，作为 Eclipse 的插件在 Windows、Mac OS 和 Linux 等平台上运行。它可在 UMLet 官网下载安装。

用 UMLet 建模非常简单，方法如下：

- 首先打开 UMLet，然后在窗体右上侧区域内双击想要添加的对象，该对象将被自动添加到面板中；
- 再选中刚刚添加进来的对象，并在右下角的属性面板中修改该对象的属性；
- 最后保存创建完成的 UML 模型图，如果需要还可将结果导出为其他格式的文件。



![UMLet 14.3的运行界面](http://c.biancheng.net/uploads/allimg/201127/5-20112GIA2Z4.png)
图1 UMLet 14.3的运行界面


如果要在 Eclipse 中安装 UMLet 插件，其方法如下。

1. 下载相关版本的 UMLet 插件的压缩包，然后将解压的文件 com.umlet.plugin-14.3.jar 复制到 Eclipse 下的 plugins 目录下。
2. 重启 Eclipse，选择“文件(F)” — 新建(N) ” — “其他(0)…” —“UMlet Diagram”，建立 UML 模型，如图 2 所示。

![在Eclipse中安装UMLet插件](http://c.biancheng.net/uploads/allimg/201127/5-20112GP333158.png)
图2 在Eclipse中安装UMLet插件


UMLet 在 Eclipse 中的使用方法同前面介绍的一样。

## 3.实验内容

(1) 通过《[UML类图及类图之间的关系](http://c.biancheng.net/view/8374.html)》一节的学习，在生活中找到相关实例。

(2) 用 UMLet 工具对找到的相关实例中的类的关系建模。

## 4.实验要求

所设计的实验必须满足以下两点。

1. 类图中至少有一个类包含相关属性和方法，目的是掌握属性和方法的画法。
2. 所举的若干实例要包含前面介绍的 UML 类与类之间的 6 种关系，并正确画出其相互关系图。

## 5.实验步骤

(1) 进行需求分析，从生活中提取出相关实例。

(2) 分析以上实例，找到相关类并确定它们之间的关系，然后利用 UMLet 画出类以及类之间的关系图，图 3 以对理学家朱熹的介绍为例介绍类图的画法。



![UML中的类之间关系实例图](http://c.biancheng.net/uploads/allimg/210304/5-2103041K15bB.png)
图5 UML中的类之间关系实例图


(3) 整理实验结果，写出实验的心得体会。



# 优秀软件架构的特征

开始学习设计模式前，我们先来看看软件架构的设计过程，及需要达成的目标和尽量避免的陷阱。

## 1.代码复用

无论是开发哪种软件产品，成本和时间都是最重要的。较少的开发时间意味着可以比竞争对手更早进入市场。较低的开发成本意味着能够留出更多的营销资金，覆盖更广泛的潜在客户。

其中，代码复用是减少开发成本最常用的方式之一，其目的非常明显，即：与其反复从头开发，不如在新对象中重用已有的代码。

这个想法表面看起来很棒，但实际上要让已有的代码在全新的代码中工作，还是需要付出额外努力的。组件间紧密的耦合、对具体类而非接口的依赖和硬编码的行为都会降低代码的灵活性，使得复用这些代码变得更加困难。

使用设计模式是增加软件组件灵活性并使其易于复用的方式之一。但是，这可能也会让组件变得更加复杂。

一般情况下，复用可以分为三个层次。在最底层，可以复用类、类库、容器，也许还有一些类的“团体（例如容器和迭代器）”。

框架位于最高层。它们能帮助你精简自己的设计，可以明确解决问题所需的抽象概念，然后用类来表示这些概念并定义其关系。例如，JUnit 是一个小型框架，也是框架的“Hello, world”，其中定义了 Test、TestCase 和 TestSuite 这几个类及其关系。框架通常比单个类的颗粒度要大。你可以通过在某处构建子类来与框架建立联系。这些子类信奉“别给我们打电话，我们会给你打电话的。”

还有一个中间层次。这是我觉得设计模式所处的位置。设计模式比框架更小且更抽象。它们实际上是对一组类的关系及其互动方式的描述。当你从类转向模式，并最终到达框架的过程中，复用程度会不断增加。

中间层次的优点在于模式提供的复用方式要比框架的风险小。创建框架是一项投入重大且风险很高的工作，模式则能让你独立于具体代码来复用设计思想和理念。

## 2.扩展性

需求变化是程序员生命中唯一不变的事情。比如以下几种场景：

- 你在 Windows 平台上发布了一款游戏，现在人们想要 Mac OS 的版本。
- 你创建了一个使用方形按钮的 GUI 框架，但几个月后开始流行原型按钮。
- 你设计了一款优秀的电子商务网站，但仅仅几个月后，客户就要求新增电话订单的功能。


每个软件开发者都经历过许多相似的故事，导致它们发生的原因也不少。

首先，在完成了第一版的程序后，我们就应该做好了从头开始优化重写代码的准备，因为现在你已经能在很多方面更好的理解问题了，同时在专业水平上也有所提高，所以之前的代码现在看上去可能会显得很糟糕。

其次，可能是在你掌控之外的某些事情发生了变化，这也是导致许多开发团队转变最初想法的原因。比如，每位在网络应用中使用 Flash 的开发者都必须重新开发或移植代码，因为不断地有浏览器停止对 Flash 格式地支持。

最后，可能是需求的改变，之前你的客户对当前版本的程序感到满意，但是现在希望对程序进行 11 个“小小”的改动，使其可完成原始计划阶段中完全没有提到的功能，新增或改变功能。

当然这也有好的一面，如果有人要求你对程序进行修改，至少说明还有人关心它。因此在设计程序架构时，有经验的开发者都会尽量选择支持未来任何可能变更的方式。



# 如何正确使用设计模式

设计模式不是为每个人准备的，而是基于业务来选择设计模式，需要时就能想到它。要明白一点，技术永远为业务服务，技术只是满足业务需要的一个工具。我们需要掌握每种设计模式的应用场景、特征、优缺点，以及每种设计模式的关联关系，这样就能够很好地满足日常业务的需要。

许多设计模式的功能类似，界限不是特别清楚（为了能让大家更好的理解，每个章节后面都列出了类似功能设计模式之间的对比）。大家不要疑惑，设计模式不是为了特定场景而生的，而是为了让大家可以更好和更快地开发。

设计模式只是实现了七大设计原则的具体方式，套用太多设计模式只会陷入模式套路陷阱，最后代码写的凌乱不堪。

在实际工作中很少会规定必须使用哪种设计模式，这样只会限制别人。不能为了使用设计模式而去做架构，而是有了做架构的需求后，发现它符合某一类设计模式的结构，在将两者结合。

设计模式要活学活用，不要生搬硬套。想要游刃有余地使用设计模式，需要打下牢固的程序设计语言基础、夯实自己的编程思想、积累大量的时间经验、提高开发能力。目的都是让程序低耦合，高复用，高内聚，易扩展，易维护。

## 1. 需求驱动

不仅仅是功能性需求，需求驱动还包括性能和运行时的需求，如软件的可维护性和可复用性等方面。设计模式是针对软件设计的，而软件设计是针对需求的，一定不要为了使用设计模式而使用设计模式，否则可能会使设计变得复杂，使软件难以调试和维护。

## 2. 分析成功的模式应用项目

对现有的应用实例进行分析是一个很好的学习途径，应当注意学习已有的项目，而不仅是学习设计模式如何实现，更重要的是注意在什么场合使用设计模式。

## 3. 充分了解所使用的开发平台

设计模式大部分都是针对面向对象的软件设计，因此在理论上适合任何面向对象的语言，但随着技术的发展和编程环境的改善，设计模式的实现方式会有很大的差别。在一些平台下，某些设计模式是自然实现的。

不仅指编程语言，平台还包括平台引入的技术。例如，Java EE 引入了反射机制和依赖注入，这些技术的使用使设计模式的实现方式产生了改变。

## 4. 在编程中领悟模式

软件开发是一项实践工作，最直接的方法就是编程。没有从来不下棋却熟悉定式的围棋高手，也没有不会编程就能成为架构设计师的先例。掌握设计模式是水到渠成的事情，除了理论只是和实践积累，可能会“渐悟”或者“顿悟”。

## 5.避免设计过度

设计模式解决的是设计不足的问题，但同时也要避免设计过度。一定要牢记简洁原则，要知道设计模式是为了使设计简单，而不是更复杂。如果引入设计模式使得设计变得复杂，只能说我们把简单问题复杂化了，问题本身不需要设计模式。

这里需要把握的是需求变化的程度，一定要区分需求的稳定部分和可变部分。一个软件必然有稳定部分，这个部分就是核心业务逻辑。如果核心业务逻辑发生变化，软件就没有存在的必要，核心业务逻辑是我们需要固化的。对于可变的部分，需要判断可能发生变化的程度来确定设计策略和设计风险。要知道，设计过度与设计不足同样对项目有害。

> 学习设计模式，死记硬背是没用的，还要从实践中理解，本教程后面会结合实例和源码来讲解如何使用设计模式。

需要特别声明的是，在日常应用中，设计模式从来都不是单个设计模式独立使用的。在实际应用中，通常多个设计模式混合使用，你中有我，我中有你。下图完整地描述了设计模式之间的混用关系，希望对大家有所帮助。

<img src="GOF 23种设计模式.assets\image-20220424091245838.png" alt="image-20220424091245838"  />



# 总结软件设计七大原则

结合前几节的内容，我们一共介绍了 7 种设计原则，它们分别为开闭原则、里氏替换原则、依赖倒置原则、单一职责原则、接口隔离原则、迪米特法则和合成复用原则。

这 7 种设计原则是软件设计模式必须尽量遵循的原则，是设计模式的基础。在实际开发过程中，并不是一定要求所有代码都遵循设计原则，而是要综合考虑人力、时间、成本、质量，不刻意追求完美，要在适当的场景遵循设计原则。这体现的是一种平衡取舍，可以帮助我们设计出更加优雅的代码结构。

各种原则要求的侧重点不同，下面我们分别用一句话归纳总结软件设计模式的七大原则，如下表所示。



| 设计原则     | 一句话归纳                                                   | 目的                                       |
| ------------ | ------------------------------------------------------------ | ------------------------------------------ |
| 开闭原则     | 对扩展开放，对修改关闭                                       | 降低维护带来的新风险                       |
| 依赖倒置原则 | 高层不应该依赖低层，要面向接口编程                           | 更利于代码结构的升级扩展                   |
| 单一职责原则 | 一个类只干一件事，实现类要单一                               | 便于理解，提高代码的可读性                 |
| 接口隔离原则 | 一个接口只干一件事，接口要精简单一                           | 功能解耦，高聚合、低耦合                   |
| 迪米特法则   | 不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度 | 只和朋友交流，不和陌生人说话，减少代码臃肿 |
| 里氏替换原则 | 不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义 | 防止继承泛滥                               |
| 合成复用原则 | 尽量使用组合或者聚合关系实现代码复用，少使用继承             | 降低代码耦合                               |


实际上，这些原则的目的只有一个：降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性。

> 记忆口诀：访问加限制，函数要节俭，依赖不允许，动态加接口，父类要抽象，扩展不更改。

在程序设计时，我们应该将程序功能最小化，每个类只干一件事。若有类似功能基础之上添加新功能，则要合理使用继承。对于多方法的调用，要会运用接口，同时合理设置接口功能与数量。最后类与类之间做到低耦合高内聚。



# 一.什么是设计模式

设计模式（Design Pattern）是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。它不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。

1995 年，GoF（Gang of Four，四人组/四人帮）合作出版了《设计模式：可复用面向对象软件的基础》一书，共收录了 23 种设计模式，从此树立了软件设计模式领域的里程碑，人称「GoF设计模式」。



# 二.软件设计模式概述 

## 1.软件设计模式的产生背景

“设计模式”这个术语最初并不是出现在软件设计中，而是被用于建筑领域的设计中。

1977 年，美国著名建筑大师、加利福尼亚大学伯克利分校环境结构中心主任克里斯托夫·亚历山大（Christopher Alexander）在他的著作《建筑模式语言：城镇、建筑、构造（A Pattern Language: Towns Building Construction）中描述了一些常见的建筑设计问题，并提出了 253 种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式。

1979 年他的另一部经典著作《建筑的永恒之道》（The Timeless Way of Building）进一步强化了设计模式的思想，为后来的建筑设计指明了方向。

1987 年，肯特·贝克（Kent Beck）和沃德·坎宁安（Ward Cunningham）首先将克里斯托夫·亚历山大的模式思想应用在 Smalltalk 中的图形用户接口的生成中，但没有引起软件界的关注。

直到 1990 年，软件工程界才开始研讨设计模式的话题，后来召开了多次关于设计模式的研讨会。

1995 年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》（Design Patterns: Elements of Reusable Object-Oriented Software）一书，在本教程中收录了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4 位作者在软件开发领域里也以他们的“四人组”（Gang of Four，GoF）匿名著称。

直到今天，狭义的设计模式还是本教程中所介绍的 23 种经典设计模式。

## 2.软件设计模式的概念与意义

有关软件设计模式的定义很多，有些从模式的特点来说明，有些从模式的作用来说明。本教程给出的定义是大多数学者公认的，从以下两个方面来说明。

- **软件设计模式的概念**

  软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。

- **学习设计模式的意义**

  设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。正确使用设计模式具有以下优点。

  - 可以提高程序员的思维能力、编程能力和设计能力。

  - 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。

  - 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。

  当然，软件设计模式只是一个引导。在具体的软件幵发中，必须根据设计的应用系统的特点和要求来恰当选择。对于简单的程序开发，苛能写一个简单的算法要比引入某种设计模式更加容易。但对大项目的开发或者框架设计，用设计模式来组织代码显然更好。

## 3.软件设计模式的基本要素

软件设计模式使人们可以更加简单方便地复用成功的设计和体系结构，它通常包含以下几个基本要素：模式名称、别名、动机、问题、解决方案、效果、结构、模式角色、合作关系、实现方法、适用性、已知应用、例程、模式扩展和相关模式等，其中最关键的元素包括以下 4 个主要部分。

- **模式名称**

  每一个模式都有自己的名字，通常用一两个词来描述，可以根据模式的问题、特点、解决方案、功能和效果来命名。模式名称（PatternName）有助于我们理解和记忆该模式，也方便我们来讨论自己的设计。

- **问题**

  问题（Problem）描述了该模式的应用环境，即何时使用该模式。它解释了设计问题和问题存在的前因后果，以及必须满足的一系列先决条件。

- **解决方案**

  模式问题的解决方案（Solution）包括设计的组成成分、它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象的 组合）来解决这个问题。

- **效果**

  描述了模式的应用效果以及使用该模式应该权衡的问题，即模式的优缺点。主要是对时间和空间的衡量，以及该模式对系统的灵活性、扩充性、可移植性的影响，也考虑其实现问题。显式地列出这些效果（Consequence）对理解和评价这些模式有很大的帮助。



# 二.GoF 的 23 种设计模式

[设计模式](http://c.biancheng.net/design_pattern/)有两种分类方法，即根据模式的目的来分和根据模式的作用的范围来分。

## 1. 根据目的来分

根据模式是用来完成什么工作来划分，这种方式可分为创建型模式、结构型模式和行为型模式 3 种。

- 创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。

- 结构型模式：用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。

- 行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。

## 2. 根据作用范围来分

根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种。

- 类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。

- 对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。


表 1 介绍了这 23 种设计模式的分类。

| 范围\目的 | 创建型模式                | 结构型模式                                  | 行为型模式                                               |
| --------- | ------------------------- | ------------------------------------------- | -------------------------------------------------------- |
| 类模式    | 工厂方法                  | (类）适配器                                 | 模板方法、解释器                                         |
| 对象模式  | 单例 原型 抽象工厂 建造者 | 代理 (对象）适配器 桥接 装饰 外观 享元 组合 | 策略 命令 职责链 状态 观察者 中介者 迭代器 访问者 备忘录 |

## 3. GoF的23种设计模式的功能

前面说明了 GoF 的 23 种设计模式的分类，现在对各个模式的功能进行介绍。

1. 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
2. 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
3. 工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
4. 抽象工厂（Abstract Factory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
5. 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。
6. 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
7. 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
8. 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。
9. 装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。
10. 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
11. 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。
12. 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。
13. 模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
14. 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
15. 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
16. 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。
17. 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。
18. 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
19. 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
20. 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
21. 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。
22. 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
23. 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。


必须指出，这 23 种设计模式不是孤立存在的，很多模式之间存在一定的关联关系，在大的系统开发中常常同时使用多种设计模式，希望读者认真学好它们。

# 三.23种设计模式(Design Patterns)

## 创建型设计模式

创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。

创建型模式分为以下几种。

- 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
- 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
- 工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
- 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
- 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。


以上 5 种创建型模式，除了[工厂方法模式](http://c.biancheng.net/view/1348.html)属于类创建型模式，其他的全部属于对象创建型模式，我们将在之后的教程中详细地介绍它们的特点、结构与应用。

### 1.单例模式(Singleton)

- #### Intro 简介

  在有些系统中，为了节省内存资源、保证数据内容的一致性，对某些类要求只能创建一个实例，这就是所谓的单例模式。

- #### 定义：

  > 单例（Singleton）模式的定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。例如，Windows 中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示内容的不一致等错误。

  在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、多线程中的线程池、显卡的驱动程序对象、打印机的后台处理服务、应用程序的日志对象、数据库的连接池、网站的计数器、Web 应用的配置对象、应用程序中的对话框、系统中的缓存等常常被设计成单例。

  单例模式在现实生活中的应用也非常广泛，例如公司 CEO、部门经理等都属于单例模型。J2EE 标准中的 [Servlet](http://c.biancheng.net/servlet/)Context 和 ServletContextConfig、[Spring](http://c.biancheng.net/spring/) 框架应用中的 ApplicationContext、数据库中的连接池等也都是单例模式。

  单例模式有 3 个特点：

  1. 单例类只有一个实例对象；
  2. 该单例对象必须由单例类自行创建；
  3. 单例类对外提供一个访问该单例的全局访问点。

- #### 单例模式的优点和缺点

  单例模式的优点：

  - 单例模式可以保证内存里只有一个实例，减少了内存的开销。
  - 可以避免对资源的多重占用。
  - 单例模式设置全局访问点，可以优化和共享资源的访问。

  单例模式的缺点：

    - 单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。

    - 在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。

    - 单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。

  > 单例模式看起来非常简单，实现起来也非常简单。单例模式在面试中是一个高频面试题。希望大家能够认真学习，掌握单例模式，提升核心竞争力，给面试加分，顺利拿到 Offer。

- #### 单例模式的应用场景

  单例模式的应用场景主要有以下几个方面。

  - 需要频繁创建的一些类，使用单例可以降低系统的内存压力，减少 GC。
  - 某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。
  - 某些类创建实例时占用资源较多，或实例化耗时较长，且经常使用。
  - 某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。
  - 频繁访问数据库或文件的对象。
  - 对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套。
  - 当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。

- #### 单例模式的结构与实现

  单例模式是[设计模式](http://c.biancheng.net/design_pattern/)中最简单的模式之一。通常，普通类的构造函数是公有的，外部类可以通过“new 构造函数()”来生成多个实例。但是，如果将类的构造函数设为私有的，外部类就无法调用该构造函数，也就无法生成多个实例。这时该类自身必须定义一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例。

  下面来分析其基本结构和实现方法。

  ##### 1. 模式的结构

  单例模式的主要角色如下。

  - 单例类：包含一个实例且能自行创建这个实例的类。

  - 访问类：使用单例的类。

    <img src="GOF 23种设计模式.assets\image-20220424103434690.png" alt="image-20220424103434690" style="zoom: 80%;" />

  ##### 2.模式的实现

  Singleton 模式通常有两种实现形式。

  ​	第 1 种：懒汉式单例 - 该模式的特点是类加载时没有生成单例，只有当第一次调用 lnstance 方法时才去创建这个单例

  ​	第 2 种：饿汉式单例 - 该模式的特点是类一旦加载就创建一个单例，保证在调用 Instance 方法之前单例已经存在了。

  ```c#
  /// <summary>
  /// 双重判空加锁，饱汉模式（懒汉式），用到的时候再去实例化
  /// </summary>
  public class Singleton
  {
      private static Singleton _instance;
      private static readonly object SyncLock = new();
  
      private Singleton()
      {
      }
  
      public static Singleton GetInstance()
      {
          if (_instance == null)
          {
              lock (SyncLock)
              {
                  if (_instance == null)
                  {
                      _instance = new Singleton();
                  }
              }
          }
          return _instance;
      }
  }
  
  /// <summary>
  /// 饿汉模式-就是屌丝，担心饿死。类加载就给准备好
  /// </summary>
  public sealed class Singleton1
  {
      /// <summary>
      /// 静态初始化，由 CLR 去创建
      /// </summary>
      private static readonly Singleton1 Instance = new();
  
      private Singleton1()
      {
      }
  
      public static Singleton1 GetInstance() => Instance;
  }
  /// <summary>
  /// 使用 ConcurrentDictionary 实现的单例方法，用到的时候再去实例化
  /// 这种方式类似于双重锁定方式，只是使用了并发集合代替了双重判断和 lock
  /// </summary>
  public class Singleton2
  {
      private static readonly ConcurrentDictionary<int, Singleton2> Instances = new();
  
      private Singleton2()
      {
      }
  
      public static Singleton2 GetInstance() => Instances.GetOrAdd(1, k => new Singleton2());
  }
  /// <summary>
  /// 使用 Lazy 实现的单例方法，用到的时候再去实例化
  /// </summary>
  public class Singleton3
  {
      private static readonly Lazy<Singleton3>
          LazyInstance = new(() => new Singleton3());
  
      private Singleton3()
      {
      }
  
      public static Singleton3 GetInstance() => LazyInstance.Value;
  }
  
  /** Program.cs **/
  Console.WriteLine("Singleton");
  Enumerable.Range(1, 10).Select(i => Task.Run(() =>
  {
      Console.WriteLine($"{Singleton.GetInstance().GetHashCode()}");
  })).WhenAll().Wait();
  
  Console.WriteLine("Singleton1");
  Enumerable.Range(1, 10).Select(i => Task.Run(() =>
  {
      Console.WriteLine($"{Singleton1.GetInstance().GetHashCode()}");
  })).WhenAll().Wait();
  
  Console.WriteLine("Singleton2");
  Enumerable.Range(1, 10).Select(i => Task.Run(() =>
  {
      Console.WriteLine($"{Singleton2.GetInstance().GetHashCode()}");
  })).WhenAll().Wait();
  
  Console.WriteLine("Singleton3");
  Enumerable.Range(1, 10).Select(i => Task.Run(() =>
  {
      Console.WriteLine($"{Singleton3.GetInstance().GetHashCode()}");
  })).WhenAll().Wait();
  
  Console.ReadLine();
  ```

  ##### 3.单例模式的应用实例

  【例1】用懒汉式单例模式模拟产生美国当今总统对象。

  分析：在每一届任期内，美国的总统只有一人，所以本实例适合用单例模式实现，图 2 所示是用懒汉式单例实现的结构图。

  <img src="GOF 23种设计模式.assets\image-20220424105108212.png" alt="image-20220424105108212" style="zoom:67%;" />

  ```c#
  namespace SingletonPattern;
  
  public class President
  {
      private static President _instance; //保证instance在所有线程中同步
  
      ////private避免类在外部被实例化
      private President()
      {
          Console.WriteLine("产生一个总统");
      }
      public static President GetInstance()
      {
          if (_instance == null)
          {
              _instance = new President();
          } else
          {
              Console.WriteLine("已经有一个总统了，不能产生新的总统！");
          }
          return _instance;
      }
  
      public void getName()
      {
          Console.WriteLine("我是美国总统：特朗普。");
      }
  }
  /** Program.cs **/
  {
      President president = President.GetInstance();
      president.getName();
      President president1 = President.GetInstance();
      president1.getName();
      if(president == president1) {
          Console.WriteLine("他们是同一人！");
      } else
      {
          Console.WriteLine("他们不是同一人！");
      }
  }
  /*
  	运行结果：
  	产生一个总统
      我是美国总统：特朗普。
      已经有一个总统了，不能产生新的总统！
      我是美国总统：特朗普。
      他们是同一人！
  */
  ```

  【例2】用饿汉式单例模式模拟产生猪八戒对象。

  分析：同上例类似，猪八戒也只有一个，所以本实例同样适合用单例模式实现。图 3 所示是用饿汉式单例实现的结构图。

  分析：同上例类似，猪八戒也只有一个，所以本实例同样适合用单例模式实现。本实例由于要显示猪八戒的图像（[点此下载该程序所要显示的猪八戒图片](http://c.biancheng.net/uploads/soft/181113/3-1Q1131J636.zip)），所以用到了Nuget包 Spectre.Console / Spectre.Console.ImageSharp，可以获得猪八戒对象，并显示它。图 3 所示是用饿汉式单例实现的结构图。

  ![image-20220424113623404](GOF 23种设计模式.assets\image-20220424113623404.png)

  ```c#
  using Spectre.Console;
  namespace SingletonPattern;
  
  public class Bajie
  {
      private static Bajie _instance = new();
  
      private Bajie()
      {
  		AnsiConsole.Write(new CanvasImage("Images/Bajie.jpg"));
          Console.WriteLine("产生一个八戒");
      }
  
      public static Bajie GetInstance() => _instance;
  }
  
  /** Program.cs **/
  {
      Bajie bajie = Bajie.GetInstance();
      Bajie bajie1 = Bajie.GetInstance();
      if (bajie == bajie1)
      {
          Console.WriteLine("他们是同一人！");
      }
      else
      {
          Console.WriteLine("他们不是同一人！");
      }
  }
  /*
  	运行结果：
      产生一个八戒
      他们是同一人！
  */
  ```

- #### 单例模式的扩展

  单例模式可扩展为有限的多例（Multitcm）模式，这种模式可生成有限个实例并保存在 ArrayList 中，客户需要时可随机获取，其结构图如图 5 所示。

  ![image-20220424114128511](GOF 23种设计模式.assets\image-20220424114128511.png)


### 2.原型模式（Prototype）

- #### Intro 简介

  在有些系统中，存在大量相同或相似对象的创建问题，如果用传统的构造函数来创建对象，会比较复杂且耗时耗资源，用原型模式生成对象就很高效，就像孙悟空拔下猴毛轻轻一吹就变出很多孙悟空一样简单。

- #### 定义：

  > 原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。例如，Windows 操作系统的安装通常较耗时，如果复制就快了很多。在生活中复制的例子非常多，这里不一一列举了。

- #### 单例模式的优点和缺点

  原型模式的优点

  - 原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良。
  - 可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。

  原型模式的缺点

  - 需要为每一个类都配置一个 clone 方法
  - clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。
  - 当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。

- #### 原型模式的应用场景

  原型模式通常适用于以下场景。

  - 对象之间相同或相似，即只是个别的几个属性不同的时候。
  - 创建对象成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多等，需要优化资源。
  - 创建一个对象需要繁琐的数据准备或访问权限等，需要提高性能或者提高安全性。
  - 系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值。

- #### 原型模式的结构与实现

  ##### 1. 模式的结构

  原型模式包含以下主要角色。

  1. 抽象原型类：规定了具体原型对象必须实现的接口。

  2. 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。

  3. 访问类：使用具体原型类中的 clone() 方法来复制新的对象。

     <img src="GOF 23种设计模式.assets\image-20220424115101405.png" alt="image-20220424115101405"  />

  ##### 2. 模式的实现

  原型模式的克隆分为浅克隆和深克隆。

  - **浅拷贝：**创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是值类型和string类型，拷贝的就是基本类型的值；如果属性是**引用类型**，拷贝的就是内存地址（string类型除外），**所以修改其中一个对象，就会影响到另一个对象**。
  - **深拷贝：**将一个对象从内存中完整的拷贝一份出来,**从堆内存中开辟一个新的区域存放新对象**,且修改新对象和原对象的修改**不会相互影响**.

  ```c#
  /** shallow copy **/
  namespace PrototypePattern;
  /// <summary>
  /// ShallowCopy
  /// </summary>
  internal class SimpleResume : ICloneable
  {
      private string _name;
      private string _email;
  
      private string _timePeriod;
      private string _company;
      public void SetPersonalInfo(string name, string email)
      {
          _name = name;
          _email = email;
      }
      public void SetWorkExperience(string company, string timePeriod)
      {
          _company = company;
          _timePeriod = timePeriod;
      }
      public void Display()
      {
          Console.WriteLine($"{_name} {_email}");
          Console.WriteLine($"工作经历：{_timePeriod} {_company}");
      }
      public object Clone() => MemberwiseClone();
  }
  
  
  /** deep copy **/
  namespace PrototypePattern;
  internal class WorkExperience : ICloneable
  {
      public string TimePeriod { get; set; }
      public string Company { get; set; }
  
      public object Clone() => MemberwiseClone();
  }
  /// <summary>
  /// Deep Copy
  /// </summary>
  internal class ComplexResume : ICloneable
  {
      private readonly WorkExperience _workExperience;
      private string _name;
      private string _email;
  
      public ComplexResume() => _workExperience = new WorkExperience();
  
      private ComplexResume(WorkExperience workExperience) => _workExperience = (WorkExperience)workExperience.Clone();
  
      public void SetPersonalInfo(string name, string email)
      {
          _name = name;
          _email = email;
      }
      public void SetWorkExperience(string comapny, string timePeriod)
      {
          _workExperience.Company = comapny;
          _workExperience.TimePeriod = timePeriod;
      }
      public void Show()
      {
          Console.WriteLine($"{_name} {_email}");
          Console.WriteLine($"Work Experience: {_workExperience.Company} {_workExperience.TimePeriod}");
      }
      public object Clone() => new ComplexResume(_workExperience)
      {
          _name = _name,
          _email = _email
      };
  }
  
  
  /** Program.cs **/
  //shallow copy
  {
      var resume = new SimpleResume();
      resume.SetPersonalInfo("小明", "xiaoming@abc.xyz");
      resume.SetWorkExperience("xxx公司", "1990~2000");
      resume.Display();
      var resume1 = (SimpleResume)resume.Clone();
      resume1.SetWorkExperience("xxx企业", "1998~1999");
      resume1.Display();
      var resume2 = (SimpleResume)resume.Clone();
      resume2.SetPersonalInfo("xiaohong", "xiaohong@abc.xyz");
      resume2.Display();
  }
  // deep copy
  {
      var complexResume = new ComplexResume();
      complexResume.SetPersonalInfo("xiaoming", "xiaoming@abc.xyz");
      complexResume.SetWorkExperience("xiaomingTecch", "2001~2005");
      complexResume.Show();
  
      var complexResume1 = (ComplexResume)complexResume.Clone();
      complexResume1.SetPersonalInfo("xiaohong", "xiaohong@abc.xyz");
      complexResume1.Show();
  }
  Console.ReadLine();
  /*
  	运行结果：
  	小明 xiaoming@abc.xyz
      工作经历：1990~2000 xxx公司
      小明 xiaoming@abc.xyz
      工作经历：1998~1999 xxx企业
      xiaohong xiaohong@abc.xyz
      工作经历：1990~2000 xxx公司
      xiaoming xiaoming@abc.xyz
      Work Experience: xiaomingTecch 2001~2005
      xiaohong xiaohong@abc.xyz
      Work Experience: xiaomingTecch 2001~2005
  */
  ```

  ##### 3.原型模式的应用实例

  【例1】用原型模式模拟“孙悟空”复制自己。

  分析：孙悟空拔下猴毛轻轻一吹就变出很多孙悟空，这实际上是用到了原型模式。这里的孙悟空类 SunWukong 是具体原型类。

  ![image-20220424120157503](GOF 23种设计模式.assets\image-20220424120157503.png)

  【例2】用原型模式生成“三好学生”奖状。

  分析：同一学校的“三好学生”奖状除了获奖人姓名不同，其他都相同，属于相似对象的复制，同样可以用原型模式创建，然后再做简单修改就可以了。图 4 所示是三好学生奖状生成器的结构图。

  ![image-20220424120258264](GOF 23种设计模式.assets\image-20220424120258264.png)

- #### 原型模式的扩展

  原型模式可扩展为带原型管理器的原型模式，它在原型模式的基础上增加了一个原型管理器 PrototypeManager 类。该类用 HashMap 保存多个复制的原型，Client 类可以通过管理器的 get(String id) 方法从中获取复制的原型。其结构图如图 5 所示。

  ![image-20220424120708039](GOF 23种设计模式.assets\image-20220424120708039.png)

  【例3】用带原型管理器的原型模式来生成包含“圆”和“正方形”等图形的原型，并计算其面积。分析：本实例中由于存在不同的图形类，例如，“圆”和“正方形”，它们计算面积的方法不一样，所以需要用一个原型管理器来管理它们，图 6 所示是其结构图。

  ![image-20220424120803914](GOF 23种设计模式.assets\image-20220424120803914.png)

### 3.简单工厂（Simple Factory）(X)

- #### Intro 简介

  现实生活中，原始社会自给自足（没有工厂），农耕社会小作坊（简单工厂，民间酒坊），工业革命流水线（工厂方法，自产自销），现代产业链代工厂（抽象工厂，富士康）。我们的项目代码同样是由简到繁一步一步迭代而来的，但对于调用者来说，却越来越简单。

- #### Intro 简介

  在日常开发中，凡是需要生成复杂对象的地方，都可以尝试考虑使用工厂模式来代替。

  > 注意：上述复杂对象指的是类的构造函数参数过多等对类的构造有影响的情况，因为类的构造过于复杂，如果直接在其他业务类内使用，则两者的耦合过重，后续业务更改，就需要在任何引用该类的源代码内进行更改，光是查找所有依赖就很消耗时间了，更别说要一个一个修改了。

  工厂模式的定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。

  按实际业务场景划分，工厂模式有 3 种不同的实现方式，分别是简单工厂模式、工厂方法模式和抽象工厂模式。

  我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”。

  在简单工厂模式中创建实例的方法通常为静态（static）方法，因此简单工厂模式（Simple Factory Pattern）又叫作静态工厂方法模式（Static Factory Method Pattern）。

  简单来说，简单工厂模式有一个具体的工厂类，可以生成多个不同的产品，属于创建型设计模式。简单工厂模式不在 GoF 23 种设计模式之列。

  简单工厂模式每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度，违背了“开闭原则”。

  > “工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。

- #### 简单工厂的优点和缺点

  优点：

  1. 工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。工厂和产品的职责区分明确。
  2. 客户端无需知道所创建具体产品的类名，只需知道参数即可。
  3. 也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。

  缺点：

  1. 简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，违背高聚合原则。
  2. 使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度
  3. 系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂
  4. 简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构。

- #### 应用场景

  对于产品种类相对较少的情况，考虑使用简单工厂模式。使用简单工厂模式的客户端只需要传入工厂类的参数，不需要关心如何创建对象的逻辑，可以很方便地创建所需产品。

- #### 模式的结构与实现

  ##### 1.单例模式的结构

  简单工厂模式的主要角色如下：

  - 简单工厂（SimpleFactory）：是简单工厂模式的核心，负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。
  - 抽象产品（Product）：是简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口。
  - 具体产品（ConcreteProduct）：是简单工厂模式的创建目标。

  ![image-20220424121451906](GOF 23种设计模式.assets\image-20220424121451906.png)

  ##### 2.模式的实现

  - **Car**

    ```c#
    /** ICar.cs **/
    namespace SimpleFactoryPattern;
    public class Bmw : ICar
    {
        public void drive()
        {
            Console.WriteLine($"Driving Bmw ");
        }
    }
    /** Benz.cs **/
    public class Benz : ICar
    {
        public void drive()
        {
            Console.WriteLine($"Driving Benz ");
        }
    }
    /** Bmw.cs **/
    public class Bmw : ICar
    {
        public void drive()
        {
            Console.WriteLine($"Driving Bmw ");
        }
    }
    ```

  - **SimpleFactory.cs**

    ```c#
    namespace SimpleFactory;
    
    public class OperationFactory
    {
        public static Operation CreateOperation(string operate)
        {
            Operation operation = null;
            switch (operate)
            {
                case "+":
                    operation = new OperationAdd();
                    break;
    
                case "-":
                    operation = new OpertaionSub();
                    break;
    
                case "*":
                    operation = new OperationMul();
                    break;
    
                case "/":
                    operation = new OperationDiv();
                    break;
            }
            return operation;
        }
    }
    ```

  - **Program.cs**

    ```c#
    ICar car = SimpleFactory.driverCar("Benz");
    car.drive();
    
    //运行结果 - Driving Benz
    ```




### 4.工厂方法（FactoryMethod）

- #### Intro 介绍

  在现实生活中社会分工越来越细，越来越专业化。各种产品有专门的工厂生产，彻底告别了自给自足的小农经济时代，这大大缩短了产品的生产周期，提高了生产效率。同样，在软件开发中能否做到软件对象的生产和使用相分离呢？能否在满足“开闭原则”的前提下，客户随意增删或改变对软件相关对象的使用呢？这就是本节要讨论的问题。

  在《[简单工厂模式](http://c.biancheng.net/view/8387.html)》一节我们介绍了简单工厂模式，提到了简单工厂模式违背了开闭原则，而“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。

- #### 工厂方法的优点和缺点

  优点：

  1. 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。

  2. 灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。

  3. 典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。

  缺点：

  1. 类的个数容易过多，增加复杂度

  2. 增加了系统的抽象性和理解难度

  3. 抽象产品只能生产一种产品，此弊端可使用[抽象工厂模式](http://c.biancheng.net/view/1351.html)解决。

- #### 应用场景：

  1. 客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。

  2. 创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。

  3. 客户不关心创建产品的细节，只关心产品的品牌

- #### 模式的结构与实现

  工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等4个要素构成。本节来分析其基本结构和实现方法。

  ##### 1. 模式的结构

  工厂方法模式的主要角色如下。

  1. 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。
  2. 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。
  3. 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。
  4. 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。

  ![image-20220423175656853](GOF 23种设计模式.assets\image-20220423175656853.png)

  ##### 2.模式实现

  - **Car**

    ```c#
    namespace FactoryMethodPattern;
    public interface ICar
    {
        void drive();
    }
    
    public class Benz : ICar
    {
        public void drive()
        {
            Console.WriteLine($"Driving Benz ");
        }
    }
    public class Bmw : ICar
    {
        public void drive()
        {
            Console.WriteLine($"Driving Bmw ");
        }
    }
    
    ```

  - **Factory**

    ```c#
    namespace FactoryMethodPattern;
    public interface ICarFactory
    {
        ICar driverCar();
    }
    public class BenzFactory : ICarFactory
    {
        public ICar driverCar()
        {
            return new Benz();
        }
    }
    public class BmwFactory : ICarFactory
    {
        public ICar driverCar()
        {
            return new Bmw();
        }
    }
    ```
    
  - **Program.cs**

    ```c#
    // 这里显示 new 对象的地方同样可以通过 配置+反射 和 依赖注入 的方式去做，可参考 抽象工厂模式
    ICarFactory carFactory = new BmwFactory();
    ICar car = carFactory.driverCar();
    car.drive();
    
    // 依赖注入
    using var services = new ServiceCollection()
        .AddSingleton<ICarFactory, BenzFactory>()
        .BuildServiceProvider();
    
    ICarFactory iCarFactory = services.GetRequiredService<ICarFactory>();
    ICar iCar = iCarFactory.driverCar();
    iCar.drive();
    
    Console.ReadLine();
    
    /*
    	执行结果：
        Driving Bmw
        Driving Benz
    */
    ```
    

  ##### 3.模式的应用实例

  【例1】用工厂方法模式设计畜牧场。

  分析：有很多种类的畜牧场，如养马场用于养马，养牛场用于养牛，所以该实例用工厂方法模式比较适合。

  对养马场和养牛场等具体工厂类，只要定义一个生成动物的方法 newAnimal() 即可。要显示马类和牛类等具体产品类的图像，并定义一个 show() 方法来显示它们。

  客户端程序通过对象生成器类 ReadXML2 读取 XML 配置文件中的数据来决定养马还是养牛。其结构图如图 2 所示。

  ![image-20220424122627150](GOF 23种设计模式.assets\image-20220424122627150.png)

  注意：当需要生成的产品不多且不会增加，一个具体工厂类就可以完成任务时，可删除抽象工厂类。这时工厂方法模式将退化到简单工厂模式。

  

### 5.抽象工厂模式（AbstractFactory）

- #### Intro 简介

  前面介绍的[工厂方法模式](http://c.biancheng.net/view/1348.html)中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、计算机软件学院只培养计算机软件专业的学生等。

  同种类称为同等级，也就是说：[工厂方法模式](http://c.biancheng.net/view/1348.html)只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如农场里既养动物又种植物，电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。

  本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，图 1 所示的是海尔工厂和 TCL 工厂所生产的电视机与空调对应的关系图。

  ![image-20220424122933690](GOF 23种设计模式.assets\image-20220424122933690.png)

- #### 模式的定义与特点

  > 抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。

  抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。

  使用抽象工厂模式一般要满足以下条件。

  - 系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。
  - 系统一次只可能消费其中某一族产品，即同族的产品一起使用。


  抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。

  - 可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。
  - 当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品组。
  - 抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。

  其缺点是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度。

- #### 模式的应用场景

  抽象工厂模式最早的应用是用于创建属于不同操作系统的视窗构件。如 [Java](http://c.biancheng.net/java/) 的 AWT 中的 Button 和 Text 等构件在 Windows 和 UNIX 中的本地实现是不同的。

  抽象工厂模式通常适用于以下场景：

  1. 当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。
  2. 系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。
  3. 系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。

- #### 模式的结构与实现

  抽象工厂模式同工厂方法模式一样，也是由抽象工厂、具体工厂、抽象产品和具体产品等 4 个要素构成，但抽象工厂中方法个数不同，抽象产品的个数也不同。现在我们来分析其基本结构和实现方法。

  ##### 1. 模式的结构

  抽象工厂模式的主要角色如下。

  1. 抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。
  2. 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。
  3. 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。
  4. 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。

  <img src="GOF 23种设计模式.assets\image-20220424123533627.png" alt="image-20220424123533627" style="zoom:80%;" />

  ##### 2.模型实现

  - **Product**

    ```c#
    namespace AbstractFactoryPattern;
    public interface ITransportation
    {
        void drive();
    }
    /** Car.cs **/
    public class BenzCar : ITransportation
    {
        public void drive()
        {
            Console.WriteLine($"Driving Benz Car ");
        }
    }
    public class BmwCar : ITransportation
    {
        public void drive()
        {
            Console.WriteLine($"Driving Bmw Car ");
        }
    }
    /** Tank.cs **/
    public class BmwTank : ITransportation
    {
        public void drive()
        {
            Console.WriteLine($"Driving Bmw Tank ");
        }
    }
    public class BenzTank : ITransportation
    {
        public void drive()
        {
            Console.WriteLine($"Driving Benz Tank ");
        }
    }
    /** Plane.cs **/
    public class BmwPlane : ITransportation
    {
        public void drive()
        {
            Console.WriteLine($"Driving Bmw Plane ");
        }
    }
    public class BenzPlane : ITransportation
    {
        public void drive()
        {
            Console.WriteLine($"Driving Benz Plane ");
        }
    }
    ```

  - **Factory**

    ```c#
    namespace AbstractFactoryPattern;
    public interface IAbstractFactory
    {
        //制造汽车
        abstract ITransportation driverCar();
    
        //制造飞机
        abstract ITransportation driverPlane();
    
        //制造坦克
        abstract ITransportation driverTank();
    
    }
    /** BmwFactory.cs **/
    public class BmwFactory : IAbstractFactory
    {
        public ITransportation driverCar()
        {
            return new BmwCar();
        }
        public ITransportation driverPlane()
        {
            return new BmwPlane();
        }
        public ITransportation driverTank()
        {
            return new BmwTank();
        }
    }
    /** BenzFactory.cs **/
    public class BenzFactory : IAbstractFactory
    {
        public ITransportation driverCar()
        {
            return new BenzCar();
        }
        public ITransportation driverPlane()
        {
            return new BenzPlane();
        }
        public ITransportation driverTank()
        {
            return new BenzTank();
        }
    }
    ```

  - **Program.cs**

    ```c#
    // AbstractFactory
    {
        IAbstractFactory factory = new BmwFactory();
        ITransportation car = factory.driverCar();
        car.drive();
    }
    // AbstractFactory + Reflection
    {
        IAbstractFactory item = Reflection.CreateInstance();
        item.driverTank().drive();
    }
    // AbstractFactory + DependencyInjection
    {
        using var services = new ServiceCollection()
            .AddSingleton<IAbstractFactory, BmwFactory>()
            .BuildServiceProvider();
    
        IAbstractFactory dbFactory = services.GetRequiredService<IAbstractFactory>();
        dbFactory.driverPlane().drive();
    }
    
    Console.ReadLine();
    /*
    	执行结果：
        Driving Bmw Car
        Driving Benz Tank
        Driving Bmw Plane
    */
    ```

  ##### 3.模型应用实例

  【例1】用抽象工厂模式设计农场类。

  分析：农场中除了像畜牧场一样可以养动物，还可以培养植物，如养马、养牛、种菜、种水果等，所以本实例比前面介绍的畜牧场类复杂，必须用抽象工厂模式来实现。

  本例用抽象工厂模式来设计两个农场，一个是韶关农场用于养牛和种菜，一个是上饶农场用于养马和种水果，可以在以上两个农场中定义一个生成动物的方法 newAnimal() 和一个培养植物的方法 newPlant()。

  对马类、牛类、蔬菜类和水果类等具体产品类，由于要显示它们的图像（[点此下载图片](http://c.biancheng.net/uploads/soft/181113/3-1Q114160J0.zip)），所以它们的构造函数中用到了 JPanel、JLabel 和 ImageIcon 等组件，并定义一个 show() 方法来显示它们。

  客户端程序通过对象生成器类 ReadXML 读取 XML 配置文件中的数据来决定养什么动物和培养什么植物（[点此下载 XML 文件](http://c.biancheng.net/uploads/soft/181113/3-1Q114160S7.zip)）。其结构图如图 3 所示。

  <img src="GOF 23种设计模式.assets\image-20220424124321062.png" alt="image-20220424124321062" style="zoom:80%;" />

- #### 模式的扩展

  抽象工厂模式的扩展有一定的“开闭原则”倾斜性：

  1. 当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。
  2. 当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。

  另一方面，当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。

  

### 6.建造者模式（Builder）

- #### Intro 简介

  在软件开发过程中有时需要创建一个复杂的对象，这个复杂对象通常由多个子部件按一定的步骤组合而成。例如，计算机是由 CPU、主板、内存、硬盘、显卡、机箱、显示器、键盘、鼠标等部件组装而成的，采购员不可能自己去组装计算机，而是将计算机的配置要求告诉计算机销售公司，计算机销售公司安排技术人员去组装计算机，然后再交给要买计算机的采购员。

  

  生活中这样的例子很多，如游戏中的不同角色，其性别、个性、能力、脸型、体型、服装、发型等特性都有所差异；还有汽车中的方向盘、发动机、车架、轮胎等部件也多种多样；每封电子邮件的发件人、收件人、主题、内容、附件等内容也各不相同。

  

  以上所有这些产品都是由多个部件构成的，各个部件可以灵活选择，但其创建步骤都大同小异。这类产品的创建无法用前面介绍的工厂模式描述，只有建造者模式可以很好地描述该类产品的创建。

- #### 模式的定义与特点

  建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的[设计模式](http://c.biancheng.net/design_pattern/)被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。

  该模式的主要优点如下：

  1. 封装性好，构建和表示分离。
  2. 扩展性好，各个具体的建造者相互独立，有利于系统的解耦。
  3. 客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。

  其缺点如下：

      1. 产品的组成部分必须相同，这限制了其使用范围。
      2. 如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。

   建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而[工厂方法模式](http://c.biancheng.net/view/1348.html)更注重零部件的创建过程，但两者可以结合使用。

- #### 模式的应用场景

  建造者模式唯一区别于工厂模式的是针对复杂对象的创建。也就是说，如果创建简单对象，通常都是使用工厂模式进行创建，而如果创建复杂对象，就可以考虑使用建造者模式。

  当需要创建的产品具备复杂创建过程时，可以抽取出共性创建过程，然后交由具体实现类自定义创建流程，使得同样的创建行为可以生产出不同的产品，分离了创建与表示，使创建产品的灵活性大大增加。

  建造者模式主要适用于以下应用场景：

  - 相同的方法，不同的执行顺序，产生不同的结果。
  - 多个部件或零件，都可以装配到一个对象中，但是产生的结果又不相同。
  - 产品类非常复杂，或者产品类中不同的调用顺序产生不同的作用。
  - 初始化一个对象特别复杂，参数多，而且很多参数都具有默认值。

- #### 建造者模式和工厂模式的区别

  通过前面的学习，我们已经了解了建造者模式，那么它和工厂模式有什么区别呢？

  - 建造者模式更加注重方法的调用顺序，工厂模式注重创建对象。
  - 创建对象的力度不同，建造者模式创建复杂的对象，由各种复杂的部件组成，工厂模式创建出来的对象都一样
  - 关注重点不一样，工厂模式只需要把对象创建出来就可以了，而建造者模式不仅要创建出对象，还要知道对象由哪些部件组成。
  - 建造者模式根据建造过程中的顺序不一样，最终对象部件组成也不一样。

- #### 模式的结构与实现

  建造者（Builder）模式由产品、抽象建造者、具体建造者、指挥者等 4 个要素构成，现在我们来分析其基本结构和实现方法。

  ##### 1.模式的结构

  建造者（Builder）模式的主要角色如下。

  1. 产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。

  2. 抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。

  3. 具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。

  4. 指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。

     ![image-20220424125321230](GOF 23种设计模式.assets\image-20220424125321230.png)

  ##### 2.模式的实现

  - (1) 产品角色：包含多个组成部件的复杂对象。

    ```c#
    namespace BuilderPattern;
    class Product
    {
        private String partA;
        private String partB;
        private String partC;
        public void setPartA(String partA)
        {
            this.partA = partA;
        }
        public void setPartB(String partB)
        {
            this.partB = partB;
        }
        public void setPartC(String partC)
        {
            this.partC = partC;
        }
        public void show()
        {
            //显示产品的特性
            Console.WriteLine("\n产品 创建----");
            Console.WriteLine(partA);
            Console.WriteLine(partB);
            Console.WriteLine(partC);
        }
    }
    ```

  - (2) 抽象建造者：包含创建产品各个子部件的抽象方法。

    ```c#
    namespace BuilderPattern;
    internal abstract class Builder
    {
        //创建产品对象
        protected Product product = new Product();
        public abstract void buildPartA();
        public abstract void buildPartB();
        public abstract void buildPartC();
        //返回产品对象
        public Product getResult()
        {
            return product;
        }
    }
    ```

  - (3) 具体建造者：实现了抽象建造者接口。

    ```c#
    namespace BuilderPattern;
    internal class ConcreteBuilder : Builder
    {
        public override void buildPartA()
        {
            product.setPartA("建造 PartA");
        }
    
        public override void buildPartB()
        {
            product.setPartB("建造 PartB");
        }
    
        public override void buildPartC()
        {
            product.setPartC("建造 PartC");
        }
    }
    ```

  - (4) 指挥者：调用建造者中的方法完成复杂对象的创建。

    ```c#
    namespace BuilderPattern;
    class Director
    {
        private Builder builder;
        public Director(Builder builder)
        {
            this.builder = builder;
        }
        //产品构建与组装方法
        public Product construct()
        {
            builder.buildPartA();
            builder.buildPartB();
            builder.buildPartC();
            return builder.getResult();
        }
    }
    ```

  - (5) 客户类。**Program.cs**

    ```c#
    Builder builder = new ConcreteBuilder();
    Director director = new Director(builder);
    Product product = director.construct();
    product.show();
    
    Console.ReadLine();
    /*
    	运行结果：
        产品 创建----
        建造 PartA
        建造 PartB
        建造 PartC
    */
    ```

  ##### 3.模型的应用实例

  【例1】用建造者（Builder）模式描述客厅装修。

  分析：客厅装修是一个复杂的过程，它包含墙体的装修、电视机的选择、沙发的购买与布局等。客户把装修要求告诉项目经理，项目经理指挥装修工人一步步装修，最后完成整个客厅的装修与布局，所以本实例用建造者模式实现比较适合。

  这里客厅是产品，包括墙、电视和沙发等组成部分。具体装修工人是具体建造者，他们负责装修与墙、电视和沙发的布局。项目经理是指挥者，他负责指挥装修工人进行装修。

  另外，客厅类中提供了 show() 方法，可以将装修效果图显示出来（点此下载装修效果图的图片）。客户端程序通过对象生成器类 ReadXML 读取 XML 配置文件中的装修方案数据（点此下载 XML 文件），调用项目经理进行装修。其类图如图 2 所示。

  <img src="GOF 23种设计模式.assets\image-20220424125528637.png" alt="image-20220424125528637" style="zoom:80%;" />

- #### 模式的扩展

  建造者（Builder）模式在应用过程中可以根据需要改变，如果创建的产品种类只有一种，只需要一个具体建造者，这时可以省略掉抽象建造者，甚至可以省略掉指挥者角色。

  

## 结构型设计模式

结构型模式描述如何将类或对象按某种布局组成更大的结构。**它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。**

由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。

结构型模式分为以下 7 种：

1. **代理（Proxy）模式：**为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
2. **适配器（Adapter）模式：**将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
3. **桥接（Bridge）模式：**将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。
4. **装饰（Decorator）模式：**动态地给对象增加一些职责，即增加其额外的功能。
5. **外观（Facade）模式：**为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
6. **享元（Flyweight）模式：**运用共享技术来有效地支持大量细粒度对象的复用。
7. **组合（Composite）模式：**将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。


以上 7 种结构型模式，除了[适配器模式](http://c.biancheng.net/view/1361.html)分为类结构型模式和对象结构型模式两种，其他的全部属于对象结构型模式，下面我们会分别、详细地介绍它们的特点、结构与应用。



**依赖关系（Dependence）：**假设A类的变化引起了B类的变化，则说明B类依赖A类。（方法里面/参数，是一种很淡的关联）

**关联关系（Association）：**两个类之间语义级别的一种强依赖关系。（班级与学生 球员与球队）

**聚合关系（Aggregation）：**表示的是整体和部分的关系，整体与部分是可以分开的(has-a)。（车和发动机）

**组合关系（Composition）：**组合也是关联关系的一种特例，它体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合。（人与心脏）

 

**继承≈实现>组合>聚合>关联>依赖**

**“组合优于继承”:继承属于强依赖，任何父类的东西，子类必须有，只能为一个父类服务；组合更灵活，还可以为抽象服务**

![image-20220421094421486](GOF 23种设计模式.assets\image-20220421094421486.png)

### 1.代理模式（Proxy pattern）- AOP

- #### Intro 简介

  在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。例如，购买火车票不一定要去火车站买，可以通过 12306 网站或者去火车票代售点买。又如找女朋友、找保姆、找工作等都可以通过找中介完成。

  在软件设计中，使用代理模式的例子也很多，例如，要访问的远程对象比较大（如视频或大图像等），其下载要花很多时间。还有因为安全原因需要屏蔽客户端直接访问真实对象，如某单位的内部数据库等。

- #### 代理模式的定义与特点

  代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。

  代理模式的主要优点有：

  - 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；
  - 代理对象可以扩展目标对象的功能；
  - 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性

  
  其主要缺点是：

  - 代理模式会造成系统设计中类的数量增加
  - 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；
  - 增加了系统的复杂度；

  > 那么如何解决以上提到的缺点呢？答案是可以使用动态代理方式

- #### 代理模式的应用场景

当无法或不想直接引用某个对象或访问某个对象存在困难时，可以通过代理对象来间接访问。使用代理模式主要有两个目的：一是保护目标对象，二是增强目标对象。

前面分析了代理模式的结构与特点，现在来分析以下的应用场景。

- 远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。
- 虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。
- 安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。
- 智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。
- 延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，[Hibernate](http://c.biancheng.net/hibernate/) 中就存在属性的延迟加载和关联表的延时加载。

- #### 代理模式的结构与实现

  代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问，下面来分析其基本结构和实现方法。

  ##### 1. 模式的结构

  代理模式的主要角色如下。

  1. 抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。
  2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。
  3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。

  ![image-20220425095016392](GOF 23种设计模式.assets\image-20220425095016392.png)

  在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。

  根据代理的创建时期，代理模式分为静态代理和动态代理。

  - 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。
  - 动态：在程序运行时，运用反射机制动态创建而成
    - **Framework** - RealProxy 
    - **DoNetCore -** Using System.Reflection / DispatchProxy (透明代理 、 真是代理)

  ##### 2. 模式的实现

  代理模式的实现代码如下：

  ```c#
  namespace ProxyPattern;
  
  // 抽象主题
  internal abstract class Subject
  {
      public abstract void Request();
  }
  
  // 真实主题
  internal class RealSubject : Subject
  {
      public override void Request()
      {
          Console.WriteLine("访问真实主题方法...");
      }
  }
  //代理1
  internal class Proxy : Subject
  {
      private readonly Subject _subject;
  
      public Proxy(Subject subject) => _subject = subject;
  
      public override void Request()
      {
          preRequest();
          _subject.Request();
          postRequest();
      }
  
      public void preRequest()
      {
          Console.WriteLine("访问真实主题之前的预处理。");
      }
      public void postRequest()
      {
          Console.WriteLine("访问真实主题之后的后续处理。");
      }
  }
  //代理2
  internal class Proxy2 : Subject
  {
      private Subject _subject;
  
      public override void Request()
      {
          if (null == _subject)
          {
              _subject = new RealSubject();
          }
          _subject.Request();
      }
  }
  
  /** Program.cs **/
  {
      Subject proxy = new Proxy(new RealSubject());
      proxy.Request();
  
      proxy = new Proxy2();
      proxy.Request();
  
      Console.ReadLine();
  }
  /*
  	执行结果：
      访问真实主题之前的预处理。
      访问真实主题方法...
      访问真实主题之后的后续处理。
  */
  ```

  ##### 3.代理模式的应用实例

  【例1】韶关“天街e角”公司是一家婺源特产公司的代理公司，用代理模式实现。

  分析：本实例中的“婺源特产公司”经营许多婺源特产，它是真实主题，提供了显示特产的 display() 方法，可以用窗体程序实现（[点此下载该实例所要显示的图片](http://c.biancheng.net/uploads/soft/181113/3-1Q115111318.zip)）。而韶关“天街e角”公司是婺源特产公司特产的代理，通过调用婺源特产公司的 display() 方法显示代理产品，当然它可以增加一些额外的处理，如包裝或加价等。客户可通过“天街e角”代理公司间接访问“婺源特产公司”的产品，图 2 所示是公司的结构图。

  ![image-20220425110924961](GOF 23种设计模式.assets\image-20220425110924961.png)

- #### 代理模式的扩展

  在前面介绍的代理模式中，代理类中包含了对真实主题的引用，这种方式存在两个缺点。

  1. 真实主题与代理主题一一对应，增加真实主题也要增加代理。
  2. 设计代理以前真实主题必须事先存在，不太灵活。采用动态代理模式可以解决以上问题，如 [Spring](http://c.biancheng.net/spring/)AOP，其结构图如图 4 所示。

  <img src="GOF 23种设计模式.assets\image-20220425095918898.png" alt="image-20220425095918898" style="zoom:80%;" />

 

### 2.适配器模式（Adapter）

- #### Intro 简介

  在现实生活中，经常出现两个对象因接口不兼容而不能在一起工作的实例，这时需要第三者进行适配。例如，讲中文的人同讲英文的人对话时需要一个翻译，用直流电的笔记本电脑接交流电源时需要一个电源适配器，用计算机访问照相机的 SD 内存卡时需要一个读卡器等。

  在软件设计中也可能出现：需要开发的具有某种业务功能的组件在现有的组件库中已经存在，但它们与当前系统的接口规范不兼容，如果重新开发这些组件成本又很高，这时用适配器模式能很好地解决这些问题。

- #### 模式的定义与特点

  适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。

  该模式的主要优点如下。

  - 客户端通过适配器可以透明地调用目标接口。
  - 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。
  - 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。
  - 在很多业务场景中符合开闭原则。

  其缺点是：

  - 适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。
  - 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。

- #### 模式的应用场景

  适配器模式（Adapter）通常适用于以下场景。

  - 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。
  - 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。

- #### 模式的结构与实现

  类适配器模式可采用多重继承方式实现，如 [C++](http://c.biancheng.net/cplus/) 可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口；[Java](http://c.biancheng.net/java/) 不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。

  对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。现在来介绍它们的基本结构。

  ##### 1. 模式的结构

  适配器模式（Adapter）包含以下主要角色。

  1. 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。
  2. 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。
  3. 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。

  类适配器模式的结构图如图 1 所示。

  ![image-20220425111500840](GOF 23种设计模式.assets\image-20220425111500840.png)

  对象适配器模式的结构图如图 2 所示。

  ![image-20220425111608639](GOF 23种设计模式.assets\image-20220425111608639.png)

  ##### 2. 模式的实现

  模式的实现代码如下：

  ```c#
  namespace AdapterPattern;
  
  //适配者接口
  internal class Adaptee
  {
      public void SpecialRequest()
      {
          Console.WriteLine("适配者中的业务代码被调用！");
      }
  }
  //目标接口
  internal class Target
  {
      public virtual void Request()
      {
          Console.WriteLine("This is a common request");
      }
  }
  //类适配器
  internal class ClassAdapter : Target
  {
      private readonly Adaptee _adaptee = new();
  
      public override void Request()
      {
          _adaptee.SpecialRequest();
      }
  }
  
  //对象适配器
  internal class ObjectAdapter : Target
  {
      private Adaptee adaptee;
      public ObjectAdapter(Adaptee adaptee)
      {
          this.adaptee = adaptee;
      }
      public override void Request()
      {
          adaptee.SpecialRequest();
      }
  }
  
  /** Program.cs **/
  Console.WriteLine("类适配器模式测试：");
  Target target = new ClassAdapter();
  target.Request();
  Console.WriteLine("对象适配器模式测试：");
  Adaptee adaptee = new Adaptee();
  target = new ObjectAdapter(adaptee);
  target.Request();
  /*
  	执行结果：
      类适配器模式测试：
      适配者中的业务代码被调用！
      对象适配器模式测试：
      适配者中的业务代码被调用！
  */
  ```

  ##### 3.模式的应用实例

  【例1】用适配器模式（Adapter）模拟新能源汽车的发动机。

  分析：新能源汽车的发动机有电能发动机（Electric Motor）和光能发动机（Optical Motor）等，各种发动机的驱动方法不同，例如，电能发动机的驱动方法 electricDrive() 是用电能驱动，而光能发动机的驱动方法 opticalDrive() 是用光能驱动，它们是适配器模式中被访问的适配者。

  客户端希望用统一的发动机驱动方法 drive() 访问这两种发动机，所以必须定义一个统一的目标接口 Motor，然后再定义电能适配器（Electric Adapter）和光能适配器（Optical Adapter）去适配这两种发动机。

  我们把客户端想访问的新能源发动机的适配器的名称放在 XML 配置文件中（[点此下载 XML 文件](http://c.biancheng.net/uploads/soft/181113/3-1Q115110A5.zip)），客户端可以通过对象生成器类 ReadXML 去读取。这样，客户端就可以通过 Motor 接口随便使用任意一种新能源发动机去驱动汽车，图 3 所示是其结构图。

  ![image-20220425112128955](GOF 23种设计模式.assets\image-20220425112128955.png)

- #### 模式的扩展

  适配器模式（Adapter）可扩展为双向适配器模式，双向适配器类既可以把适配者接口转换成目标接口，也可以把目标接口转换成适配者接口，其结构图如图 4 所示。

  ![image-20220425111822850](GOF 23种设计模式.assets\image-20220425111822850.png)



### 3.桥接模式（Bridge）

- #### Intro 简介

  在现实生活中，某些类具有两个或多个维度的变化，如图形既可按形状分，又可按颜色分。如何设计类似于 Photoshop 这样的软件，能画不同形状和不同颜色的图形呢？如果用继承方式，m 种形状和 n 种颜色的图形就有 m×n 种，不但对应的子类很多，而且扩展困难。

  当然，这样的例子还有很多，如不同颜色和字体的文字、不同品牌和功率的汽车、不同性别和职业的男女、支持不同平台和不同文件格式的媒体播放器等。如果用桥接模式就能很好地解决这些问题。

- #### 模式的定义与特点

  桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。

  通过上面的讲解，我们能很好的感觉到桥接模式遵循了里氏替换原则和依赖倒置原则，最终实现了开闭原则，对修改关闭，对扩展开放。这里将桥接模式的优缺点总结如下。

  桥接（Bridge）模式的优点是：

  - 抽象与实现分离，扩展能力强
  - 符合开闭原则
  - 符合合成复用原则
  - 其实现细节对客户透明


  缺点是：由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，能正确地识别出系统中两个独立变化的维度，这增加了系统的理解与设计难度。

- #### 模式的应用场景

  当一个类内部具备两种或多种变化维度时，使用桥接模式可以解耦这些变化的维度，使高层代码架构稳定。

  桥接模式通常适用于以下场景。

  1. 当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。
  2. 当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。
  3. 当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。


  桥接模式的一个常见使用场景就是替换继承。我们知道，继承拥有很多优点，比如，抽象、封装、多态等，父类封装共性，子类实现特性。继承可以很好的实现代码复用（封装）的功能，但这也是继承的一大缺点。

  因为父类拥有的方法，子类也会继承得到，无论子类需不需要，这说明继承具备强侵入性（父类代码侵入子类），同时会导致子类臃肿。因此，在[设计模式](http://c.biancheng.net/design_pattern/)中，有一个原则为优先使用组合/聚合，而不是继承。

  ![image-20220425120052506](GOF 23种设计模式.assets\image-20220425120052506.png)


  很多时候，我们分不清该使用继承还是组合/聚合或其他方式等，其实可以从现实语义进行思考。因为软件最终还是提供给现实生活中的人使用的，是服务于人类社会的，软件是具备现实场景的。当我们从纯代码角度无法看清问题时，现实角度可能会提供更加开阔的思路。

- #### 模式的结构与实现

  可以将抽象化部分与实现化部分分开，取消二者的继承关系，改用组合关系。

  ##### 1. 模式的结构

  桥接（Bridge）模式包含以下主要角色。

  1. 抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。
  2. 扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。
  3. 实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。
  4. 具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。

  其结构图如图 1 所示。

  ![image-20220425115746138](GOF 23种设计模式.assets\image-20220425115746138.png)

  ##### 2. 模式的实现

  模式的实现代码如下：

  ```c#
  namespace BridgePattern;
  //实现化角色
  internal abstract class Implementor
  {
      public abstract void Operation();
  }
  //具体实现化角色
  internal class ConcreteImplementorA : Implementor
  {
      public override void Operation()
      {
          Console.WriteLine("具体实现化(Concrete ImplementorA)角色被访问");
      }
  }
  internal class ConcreteImplementorB : Implementor
  {
      public override void Operation()
      {
          Console.WriteLine("具体实现化(Concrete ImplementorB)角色被访问");
      }
  }
  //抽象化角色
  internal abstract class Abstraction
  {
      protected Implementor Implementor;
  
      public void SetImplementor(Implementor implementor)
      {
          Implementor = implementor;
      }
  
      public abstract void Operation();
  }
  //扩展抽象化角色
  internal class RefinedAbstraction : Abstraction
  {
      public override void Operation()
      {
          Implementor.Operation();
          //Console.WriteLine("Invoke in RefinedAbstraction");
          Console.WriteLine("扩展抽象化(Refined Abstraction)角色被访问");
      }
  }
  /** Program.cs **/
  Abstraction abstraction = new RefinedAbstraction();
  abstraction.SetImplementor(new ConcreteImplementorA());
  abstraction.Operation();
  abstraction.SetImplementor(new ConcreteImplementorB());
  abstraction.Operation();
  Console.WriteLine();
  /*
  	执行结果：
      具体实现化(Concrete ImplementorA)角色被访问
      扩展抽象化(Refined Abstraction)角色被访问
      
      具体实现化(Concrete ImplementorB)角色被访问
      扩展抽象化(Refined Abstraction)角色被访问
  */
  ```

  ##### 3.模式的应用实例

  【例1】用桥接（Bridge）模式模拟女士皮包的选购。

  分析：女士皮包有很多种，可以按用途分、按皮质分、按品牌分、按颜色分、按大小分等，存在多个维度的变化，所以采用桥接模式来实现女士皮包的选购比较合适。

  本实例按用途分可选钱包（Wallet）和挎包（HandBag），按颜色分可选黄色（Yellow）和红色（Red）。可以按两个维度定义为颜色类和包类。（[点此下载本实例所要显示的包的图片](http://c.biancheng.net/uploads/soft/181113/3-1Q115125U5.zip)）。

  颜色类（Color）是一个维度，定义为实现化角色，它有两个具体实现化角色：黄色和红色，通过 getColor() 方法可以选择颜色；包类（Bag）是另一个维度，定义为抽象化角色，它有两个扩展抽象化角色：挎包和钱包，它包含了颜色类对象，通过 getName() 方法可以选择相关颜色的挎包和钱包。

  客户类通过 ReadXML 类从 XML 配置文件中获取包信息（[点此下载 XML 配置文件](http://c.biancheng.net/uploads/soft/181113/3-1Q115130045.zip)），并把选到的产品通过窗体显示出现，图 2 所示是其结构图。

  ![image-20220425115946682](GOF 23种设计模式.assets\image-20220425115946682.png)

- #### 模式的扩展

  在软件开发中，有时桥接（Bridge）模式可与[适配器模式](http://c.biancheng.net/view/1361.html)联合使用。当桥接（Bridge）模式的实现化角色的接口与现有类的接口不一致时，可以在二者中间定义一个适配器将二者连接起来，其具体结构图如图 5 所示。

  ![image-20220425120141030](GOF 23种设计模式.assets\image-20220425120141030.png)

  

### 4.装饰者模式（Decorator）- AOP

- #### Intro 简介

  上班族大多都有睡懒觉的习惯，每天早上上班时间都很紧张，于是很多人为了多睡一会，就会用方便的方式解决早餐问题。有些人早餐可能会吃煎饼，煎饼中可以加鸡蛋，也可以加香肠，但是不管怎么“加码”，都还是一个煎饼。在现实生活中，常常需要对现有产品增加新的功能或美化其外观，如房子装修、相片加相框等，都是装饰器模式。

  在软件开发过程中，有时想用一些现存的组件。这些组件可能只是完成了一些核心功能。但在不改变其结构的情况下，可以动态地扩展其功能。所有这些都可以釆用装饰器模式来实现。

- #### 模式的定义与特点

  装饰器（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。

  装饰器模式的主要优点有：

  - 装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用
  - 通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果
  - 装饰器模式完全遵守开闭原则

  其主要缺点是：装饰器模式会增加许多子类，过度使用会增加程序得复杂性。

- #### 模式的应用场景

  前面讲解了关于装饰器模式的结构与特点，下面介绍其适用的应用场景，装饰器模式通常在以下几种情况使用。

  - 当需要给一个现有类添加附加职责，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类。
  - 当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰器模式却很好实现。
  - 当对象的功能要求可以动态地添加，也可以再动态地撤销时。

- #### 模式的结构与实现

  通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰器模式的目标。下面来分析其基本结构和实现方法。

  ##### 1. 模式的结构

  装饰器模式主要包含以下角色。

  1. 抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。
  2. 具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。
  3. 抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。
  4. 具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。

  装饰器模式的结构图如图 1 所示。

  ![image-20220425193738276](GOF 23种设计模式.assets\image-20220425193738276.png)

  ##### 2. 模式的实现

  模式的实现代码如下：

  ```c#
  namespace DecoratorPattern;
  
  //抽象构件角色
  internal abstract class Component
  {
      public abstract void Operation();
  }
  //具体构件角色
  internal class ConcreteComponent : Component
  {
      public ConcreteComponent()
      {
          Console.WriteLine("创建具体构件角色");
      }
      public override void Operation()
      {
          Console.WriteLine("调用具体构件角色的方法operation()");
      }
  }
  //抽象装饰角色
  internal abstract class Decorator : Component
  {
      protected Component Component;
  
      public void SetComponent(Component component)
      {
          Component = component;
      }
  
      public override void Operation()
      {
          Component?.Operation();
      }
  }
  //具体装饰角色
  internal class ConcreteDecoratorA : Decorator
  {
      public override void Operation()
      {
          base.Operation();
          Console.WriteLine($"operation in DecoratorA");
          addedFunction();
      }
  
      public void addedFunction()
      {
          Console.WriteLine("为具体构件角色增加额外的功能addedFunction()");
      }
  }
  internal class ConcreteDecoratorB : Decorator
  {
      public override void Operation()
      {
          base.Operation();
          Console.WriteLine("operation in DecoratorB");
          AddBehavior();
      }
  
      private void AddBehavior()
      {
          Console.WriteLine("another behavior - B");
      }
  }
  /** Program.cs **/
  Component component = new ConcreteComponent();
  component.Operation();
  Console.WriteLine("---------------------------------");
  Decorator decoratorA = new ConcreteDecoratorA();
  decoratorA.SetComponent(component);
  decoratorA.Operation();
  Console.WriteLine("---------------------------------");
  Decorator decoratorB = new ConcreteDecoratorB();
  decoratorB.SetComponent(decorator);
  decoratorB.Operation();
  /*
  	执行结果：
      创建具体构件角色
      调用具体构件角色的方法operation()
      ---------------------------------
      调用具体构件角色的方法operation()
      operation in DecoratorA
      为具体构件角色增加额外的功能addedFunction()
      ---------------------------------
      调用具体构件角色的方法operation()
      operation in DecoratorA
      为具体构件角色增加额外的功能addedFunction()
      operation in DecoratorB
      another behavior - B
  */
  ```

  ##### 3.模式的应用实例

  【例1】用装饰器模式实现游戏角色“莫莉卡·安斯兰”的变身。

  分析：在《恶魔战士》中，游戏角色“莫莉卡·安斯兰”的原身是一个可爱少女，但当她变身时，会变成头顶及背部延伸出蝙蝠状飞翼的女妖，当然她还可以变为穿着漂亮外衣的少女。这些都可用装饰器模式来实现，在本实例中的“莫莉卡”原身有 setImage(String t) 方法决定其显示方式，而其 变身“蝙蝠状女妖”和“着装少女”可以用 setChanger() 方法来改变其外观，原身与变身后的效果用 display() 方法来显示（[点此下载其原身和变身后的图片](http://c.biancheng.net/uploads/soft/181113/3-1Q115142F6.zip)），图 2 所示是其结构图。

  ![image-20220425200656092](GOF 23种设计模式.assets\image-20220425200656092.png)

- #### 模式的扩展

  装饰器模式所包含的 4 个角色不是任何时候都要存在的，在有些应用环境下模式是可以简化的，如以下两种情况。

  (1) 如果只有一个具体构件而没有抽象构件时，可以让抽象装饰继承具体构件，其结构图如图 4 所示。

  ![image-20220425200758437](GOF 23种设计模式.assets\image-20220425200758437.png)

  (2) 如果只有一个具体装饰时，可以将抽象装饰和具体装饰合并，其结构图如图 5 所示。

  ![image-20220425200843550](GOF 23种设计模式.assets\image-20220425200843550.png)

  

### 5.外观模式（Facade）- SubSystem

- #### Intro 简介

  在现实生活中，常常存在办事较复杂的例子，如办房产证或注册一家公司，有时要同多个部门联系，这时要是有一个综合部门能解决一切手续问题就好了。

  软件设计也是这样，当一个系统的功能越来越强，子系统会越来越多，客户对系统的访问也变得越来越复杂。这时如果系统内部发生改变，客户端也要跟着改变，这违背了“开闭原则”，也违背了“迪米特法则”，所以有必要为多个子系统提供一个统一的接口，从而降低系统的耦合度，这就是外观模式的目标。

  图 1 给出了客户去当地房产局办理房产证过户要遇到的相关部门。

  ![image-20220425205815293](GOF 23种设计模式.assets\image-20220425205815293.png)

- #### 模式的定义与特点

  外观（Facade）模式又叫作门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。

  在日常编码工作中，我们都在有意无意的大量使用外观模式。只要是高层模块需要调度多个子系统（2个以上的类对象），我们都会自觉地创建一个新的类封装这些子系统，提供精简的接口，让高层模块可以更加容易地间接调用这些子系统的功能。尤其是现阶段各种第三方SDK、开源类库，很大概率都会使用外观模式。

  外观（Facade）模式是“迪米特法则”的典型应用，它有以下主要优点。

  1. 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。
  2. 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。
  3. 降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。

  外观（Facade）模式的主要缺点如下。

  1. 不能很好地限制客户使用子系统类，很容易带来未知风险。
  2. 增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。

- #### 模式的应用场景

  通常在以下情况下可以考虑使用外观模式。

  1. 对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。
  2. 当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。
  3. 当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。

- #### 模式的结构与实现

  外观（Facade）模式的结构比较简单，主要是定义了一个高层接口。它包含了对各个子系统的引用，客户端可以通过它访问各个子系统的功能。现在来分析其基本结构和实现方法。

  ##### 1. 模式的结构

  外观（Facade）模式包含以下主要角色。

  1. 外观（Facade）角色：为多个子系统对外提供一个共同的接口。
  2. 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。
  3. 客户（Client）角色：通过一个外观角色访问各个子系统的功能。

  其结构图如图 2 所示。

  ![image-20220425210118287](GOF 23种设计模式.assets\image-20220425210118287.png)

  ##### 2. 模式的实现

  模式的实现代码如下：

  ```c#
  namespace FacadePattern;
  
  //子系统角色
  public class SubSystem01
  {
      public void MethodA()
      {
          Console.WriteLine("子系统01的methodA()被调用！");
      }
  }
  //子系统角色
  public class SubSystem02
  {
      public void MethodA()
      {
          Console.WriteLine("子系统02的methodA()被调用！");
      }
  }
  //子系统角色
  public class SubSystem03
  {
      public void MethodA()
      {
          Console.WriteLine("子系统03的methodA()被调用！");
      }
  }
  //外观角色
  public class Facade
  {
      private readonly SubSystem01 _subSystem1 = new();
      private readonly SubSystem02 _subSystem2 = new();
      private readonly SubSystem03 _subSystem3 = new();
  
      public void MethodA()
      {
          _subSystem1.MethodA();
          _subSystem2.MethodA();
          _subSystem3.MethodA();
          Console.WriteLine();
      }
  }
  
  /** Program.cs **/
  var facade = new Facade();
  facade.MethodA();
  Console.ReadLine();
  /*
  	执行结果：
      子系统01的methodA()被调用！
      子系统02的methodA()被调用！
      子系统03的methodA()被调用！
  */
  ```

  ##### 3.模式的应用实例

  【例1】用“外观模式”设计一个婺源特产的选购界面。

  分析：本实例的外观角色 WySpecialty 是 JPanel 的子类，它拥有 8 个子系统角色 Specialty1~Specialty8，它们是图标类（ImageIcon）的子类对象，用来保存该婺源特产的图标（[点此下载要显示的婺源特产的图片](http://c.biancheng.net/uploads/soft/181113/3-1Q115152634.zip)）。

  外观类（WySpecialty）用 JTree 组件来管理婺源特产的名称，并定义一个事件处理方法 valueClianged(TreeSelectionEvent e)，当用户从树中选择特产时，该特产的图标对象保存在标签（JLabd）对象中。

  客户窗体对象用分割面板来实现，左边放外观角色的目录树，右边放显示所选特产图像的标签。其结构图如图 3 所示。

  ![image-20220425210619165](GOF 23种设计模式.assets\image-20220425210619165.png)

- #### 模式的扩展

  在外观模式中，当增加或移除子系统时需要修改外观类，这违背了“开闭原则”。如果引入抽象外观类，则在一定程度上解决了该问题，其结构图如图 5 所示。

  ![image-20220425210712475](GOF 23种设计模式.assets\image-20220425210712475.png)




### 6.享元模式（Flyweight）

- #### Intro 简介

  在面向对象程序设计过程中，有时会面临要创建大量相同或相似对象实例的问题。创建那么多的对象将会耗费很多的系统资源，它是系统性能提高的一个瓶颈。

  例如，围棋和五子棋中的黑白棋子，图像中的坐标点或颜色，局域网中的路由器、交换机和集线器，教室里的桌子和凳子等。这些对象有很多相似的地方，如果能把它们相同的部分提取出来共享，则能节省大量的系统资源，这就是享元模式的产生背景。

- #### 模式的定义与特点

  享元（Flyweight）模式的定义：运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。

  享元模式的主要优点是：相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。

  其主要缺点是：

  1. 为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。
  2. 读取享元模式的外部状态会使得运行时间稍微变长。

- #### 模式的应用场景

  当系统中多处需要同一组信息时，可以把这些信息封装到一个对象中，然后对该对象进行缓存，这样，一个对象就可以提供给多出需要使用的地方，避免大量同一对象的多次创建，降低大量内存空间的消耗。

  享元模式其实是[工厂方法模式](http://c.biancheng.net/view/1348.html)的一个改进机制，享元模式同样要求创建一个或一组对象，并且就是通过工厂方法模式生成对象的，只不过享元模式为工厂方法模式增加了缓存这一功能。

  前面分析了享元模式的结构与特点，下面分析它适用的应用场景。享元模式是通过减少内存中对象的数量来节省内存空间的，所以以下几种情形适合采用享元模式。

  1. 系统中存在大量相同或相似的对象，这些对象耗费大量的内存资源。
  2. 大部分的对象可以按照内部状态进行分组，且可将不同部分外部化，这样每一个组只需保存一个内部状态。
  3. 由于享元模式需要额外维护一个保存享元的[数据结构](http://c.biancheng.net/data_structure/)，所以应当在有足够多的享元实例时才值得使用享元模式。

- #### 模式的结构与实现

  享元模式的定义提出了两个要求，细粒度和共享对象。因为要求细粒度，所以不可避免地会使对象数量多且性质相近，此时我们就将这些对象的信息分为两个部分：内部状态和外部状态。

  - 内部状态指对象共享出来的信息，存储在享元信息内部，并且不回随环境的改变而改变；
  - 外部状态指对象得以依赖的一个标记，随环境的改变而改变，不可共享。

  
  比如，连接池中的连接对象，保存在连接对象中的用户名、密码、连接URL等信息，在创建对象的时候就设置好了，不会随环境的改变而改变，这些为内部状态。而当每个连接要被回收利用时，我们需要将它标记为可用状态，这些为外部状态。

  享元模式的本质是缓存共享对象，降低内存消耗。

  ##### 1. 模式的结构

  享元模式的主要角色有如下。

  1. 抽象享元角色（Flyweight）：是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。
  2. 具体享元（Concrete Flyweight）角色：实现抽象享元角色中所规定的接口。
  3. 非享元（Unsharable Flyweight)角色：是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中。
  4. 享元工厂（Flyweight Factory）角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。

  
  图 1 是享元模式的结构图，其中：

  - UnsharedConcreteFlyweight 是非享元角色，里面包含了非共享的外部状态信息 info；

  - Flyweight 是抽象享元角色，里面包含了享元方法 operation(UnsharedConcreteFlyweight state)，非享元的外部状态以参数的形式通过该方法传入；

  - ConcreteFlyweight 是具体享元角色，包含了关键字 key，它实现了抽象享元接口；

  - FlyweightFactory 是享元工厂角色，它是关键字 key 来管理具体享元；

  - 客户角色通过享元工厂获取具体享元，并访问具体享元的相关方法。

    ![image-20220426080644377](GOF 23种设计模式.assets\image-20220426080644377.png)

  ##### 2. 模式的实现

  代理模式的实现代码如下：

  ```c#
  using System.Collections.Concurrent;
  
  namespace FlyweightPattern;
  //抽象角色
  internal abstract class Flyweight
  {
      public abstract void Operation(string key);
  }
  //非享元角色
  internal class UnsharedFlyweight : Flyweight
  {
      public override void Operation(string key)
      {
          Console.WriteLine("具体非享元 "+ key + " 被调用");
      }
  }
  //具体享元角色
  internal class ConcreteFlyweight : Flyweight
  {
      private String key;
      public ConcreteFlyweight(String key)
      {
          this.key = key;
          Console.WriteLine("具体享元 " + key + " 被创建！");
      }
      public override void Operation(string key)
      {
          Console.WriteLine("具体享元 " + key + " 被调用，");
      }
  }
  //享元工厂角色
  internal class FlyWeightFactory
  {
      //private readonly ConcurrentDictionary<string, Flyweight> _flyweights = new();
      //public Flyweight GetFlyweight(string name) => _flyweights.GetOrAdd(name, n => new ConcreteFlyweight());
  
      private readonly ConcurrentDictionary<string, Flyweight> _flyweights = new ConcurrentDictionary<string, Flyweight>();
  
      public Flyweight GetFlyweight(string key)
      {
          //return _flyweights.GetOrAdd(key, n => new ConcreteFlyweight(key));
          _flyweights.TryGetValue(key,out Flyweight flyweight);
          if (flyweight == null)
          {
              flyweight = new ConcreteFlyweight(key);
              _flyweights.TryAdd(key, flyweight);
          }
          else
          {
              Console.WriteLine("具体享元 " + key + " 已经存在，被成功获取！");
          }
          return flyweight;
      }
  }
  
  /** Program.cs **/
  FlyWeightFactory factory = new FlyWeightFactory();
  factory.GetFlyweight("X").Operation("X");
  factory.GetFlyweight("Y").Operation("Y");
  factory.GetFlyweight("X").Operation("X");
  factory.GetFlyweight("X").Operation("X");
  new UnsharedFlyweight().Operation("Z");
  Console.ReadLine();
  /*
  	执行结果：
      具体享元 X 被创建！
      具体享元 X 被调用，
      具体享元 Y 被创建！
      具体享元 Y 被调用，
  
      具体享元 X 已经存在，被成功获取！
      具体享元 X 被调用，
      具体享元 X 已经存在，被成功获取！
      具体享元 X 被调用，
  
      具体非享元 Z 被调用
  */
  ```

  ##### 3.模式的应用实例

  【例1】享元模式在五子棋游戏中的应用。

  分析：五子棋同围棋一样，包含多个“黑”或“白”颜色的棋子，所以用享元模式比较好。

  本实例中:

  - 棋子（ChessPieces）类是抽象享元角色，它包含了一个落子的 DownPieces(Graphics g,Point pt) 方法；
  - 白子（WhitePieces）和黑子（BlackPieces）类是具体享元角色，它实现了落子方法；
  - Point 是非享元角色，它指定了落子的位置；
  - WeiqiFactory 是享元工厂角色，它通过 ArrayList 来管理棋子，并且提供了获取白子或者黑子的 getChessPieces(String type) 方法；
  - 客户类（Chessboard）利用 Graphics 组件在框架窗体中绘制一个棋盘，并实现 mouseClicked(MouseEvent e) 事件处理方法，该方法根据用户的选择从享元工厂中获取白子或者黑子并落在棋盘上。

  图 2 所示是其结构图。

  ![image-20220426103952610](GOF 23种设计模式.assets\image-20220426103952610.png)

- #### 模式的扩展

  在前面介绍的享元模式中，其结构图通常包含可以共享的部分和不可以共享的部分。在实际使用过程中，有时候会稍加改变，即存在两种特殊的享元模式：单纯享元模式和复合享元模式，下面分别对它们进行简单介绍。

  (1) 单纯享元模式，这种享元模式中的所有的具体享元类都是可以共享的，不存在非共享的具体享元类，其结构图如图 4 所示。

  ![image-20220426104235342](GOF 23种设计模式.assets\image-20220426104235342.png)

  (2) 复合享元模式，这种享元模式中的有些享元对象是由一些单纯享元对象组合而成的，它们就是复合享元对象。虽然复合享元对象本身不能共享，但它们可以分解成单纯享元对象再被共享，其结构图如图 5 所示。

  ![image-20220426104308083](GOF 23种设计模式.assets\image-20220426104308083.png)



### 7.组合模式（Composite）

- #### Intro 简介

  在现实生活中，存在很多“部分-整体”的关系，例如，大学中的部门与学院、总公司中的部门与分公司、学习用品中的书与书包、生活用品中的衣服与衣柜、以及厨房中的锅碗瓢盆等。在软件开发中也是这样，例如，文件系统中的文件与文件夹、窗体程序中的简单控件与容器控件等。对这些简单对象与复合对象的处理，如果用组合模式来实现会很方便。

- #### 模式的定义与特点

  组合（Composite Pattern）模式的定义：有时又叫作整体-部分（Part-Whole）模式，它是一种将对象组合成树状的层次结构的模式，用来表示“整体-部分”的关系，使用户对单个对象和组合对象具有一致的访问性，属于结构型[设计模式](http://c.biancheng.net/design_pattern/)。

  组合模式一般用来描述整体与部分的关系，它将对象组织到树形结构中，顶层的节点被称为根节点，根节点下面可以包含树枝节点和叶子节点，树枝节点下面又可以包含树枝节点和叶子节点，树形结构图如下。

  <img src="GOF 23种设计模式.assets\image-20220426105403831.png" alt="image-20220426105403831" style="zoom:80%;" />

  由上图可以看出，其实根节点和树枝节点本质上属于同一种数据类型，可以作为容器使用；而叶子节点与树枝节点在语义上不属于用一种类型。但是在组合模式中，会把树枝节点和叶子节点看作属于同一种数据类型（用统一接口定义），让它们具备一致行为。

  这样，在组合模式中，整个树形结构中的对象都属于同一种类型，带来的好处就是用户不需要辨别是树枝节点还是叶子节点，可以直接进行操作，给用户的使用带来极大的便利。

  组合模式的主要优点有：

  1. 组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；
  2. 更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；

  其主要缺点是：

  1. 设计较复杂，客户端需要花更多时间理清类之间的层次关系；
  2. 不容易限制容器中的构件；
  3. 不容易用继承的方法来增加构件的新功能；

- #### 模式的应用场景

  前面分析了组合模式的结构与特点，下面分析它适用的以下应用场景。

  1. 在需要表示一个对象整体与部分的层次结构的场合。
  2. 要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合。

- #### 模式的结构与实现

  组合模式的结构不是很复杂，下面对它的结构和实现进行分析

  ##### 1. 模式的结构

  组合模式包含以下主要角色。

  1. 抽象构件（Component）角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。（总的抽象类或接口，定义一些通用的方法，比如新增、删除）
  2. 树叶构件（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于继承或实现抽象构件。
  3. 树枝构件（Composite）角色 / 中间构件：是组合中的分支节点对象，它有子节点，用于继承和实现抽象构件。它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法。

  
  组合模式分为透明式的组合模式和安全式的组合模式。

  **(1) 透明方式**

  在该方式中，由于抽象构件声明了所有子类中的全部方法，所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的。但其缺点是：树叶构件本来没有 Add()、Remove() 及 GetChild() 方法，却要实现它们（空实现或抛异常），这样会带来一些安全性问题。其结构图如图 1 所示。

  ![image-20220426105626877](GOF 23种设计模式.assets\image-20220426105626877.png)

  **(2) 安全方式**

  在该方式中，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题，但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性。其结构图如图 2 所示。

  ![image-20220426105655052](GOF 23种设计模式.assets\image-20220426105655052.png)

  ##### 2. 模式的实现

  假如要访问集合 c0={leaf1,{leaf2,leaf3}} 中的元素，其对应的树状图如图 3 所示。

  ![image-20220426105726530](GOF 23种设计模式.assets\image-20220426105726530.png)

  **(1) 透明组合模式**

  下面为透明式的组合模式的实现代码。

  ```c#
  namespace CompositePattern;
  
  //抽象构件
  internal abstract class Component
  {
      protected string Name;
  
      protected Component(string name)
      {
          Name = name;
      }
  
      public abstract void Add(Component c);
      public abstract void Remove(Component c);
      public abstract void operation(int depth);
  }
  //树叶构件
  internal class Leaf : Component
  {
      public Leaf(string name) : base(name)
      { }
  
      public override void Add(Component c)
      { }
      public override void Remove(Component c)
      { }
      public override void operation(int depth)
      {
          Console.WriteLine($"{new string('-', depth)} Leaf {Name}：被访问！");
      }
  }
  //树枝构件
  internal class Composite : Component
  {
      private readonly List<Component> _children = new();
  
      public Composite(string name) : base(name)
      { }
  
      public override void Add(Component c)
      {
          _children.Add(c);
      }
      public override void Remove(Component c)
      {
          _children.Remove(c);
      }
      public override void operation(int depth)
      {
          Console.WriteLine($"{new string('-', depth)} {Name}");
          foreach (var component in _children)
          {
              component.operation(depth + 2);
          }
      }
  }
  
  /** Program.cs **/
  Component c0 = new Composite("c0");
  Component c1 = new Composite("c1");
  Component leaf1 = new Leaf("1");
  Component leaf2 = new Leaf("2");
  Component leaf3 = new Leaf("3");
  c0.Add(leaf1);
  c0.Add(c1);
  c1.Add(leaf2);
  c1.Add(leaf3);
  c0.operation(0);
  /*
  	执行结果：
       c0
      -- Leaf 1：被访问！
      -- c1
      ---- Leaf 2：被访问！
      ---- Leaf 3：被访问！
  */
  ```

  **(2) 安全组合模式**

  安全式的组合模式与透明式组合模式的实现代码类似，只要对其做简单修改就可以了，代码如下。

  首先修改 Component 代码，只保留层次的公共行为。

  ```c#
  internal abstract class Component
  {
      protected string Name;
      protected Component(string name)
      {
          Name = name;
      }
      public abstract void operation(int depth);
  }
  ```

  然后修改客户端代码，将树枝构件类型更改为 Composite 类型，以便获取管理子类操作的方法。

  ```c#
  Composite c0 = new Composite("c0");
  Composite c1 = new Composite("c1");
  Component leaf1 = new Leaf("1");
  Component leaf2 = new Leaf("2");
  Component leaf3 = new Leaf("3");
  c0.Add(leaf1);
  c0.Add(c1);
  c1.Add(leaf2);
  c1.Add(leaf3);
  c0.operation(0);
  ```

  ##### 3.模式的应用实例

  【例1】用组合模式实现当用户在商店购物后，显示其所选商品信息，并计算所选商品总价的功能。

  说明：假如李先生到韶关“天街e角”生活用品店购物，用 1 个红色小袋子装了 2 包婺源特产（单价 7.9 元）、1 张婺源地图（单价 9.9 元）；用 1 个白色小袋子装了 2 包韶关香藉（单价 68 元）和 3 包韶关红茶（单价 180 元）；用 1 个中袋子装了前面的红色小袋子和 1 个景德镇瓷器（单价 380 元）；用 1 个大袋子装了前面的中袋子、白色小袋子和 1 双李宁牌运动鞋（单价 198 元）。

  最后“大袋子”中的内容有：{1 双李宁牌运动鞋（单价 198 元）、白色小袋子{2 包韶关香菇（单价 68 元）、3 包韶关红茶（单价 180 元）}、中袋子{1 个景德镇瓷器（单价 380 元）、红色小袋子{2 包婺源特产（单价 7.9 元）、1 张婺源地图（单价 9.9 元）}}}，现在要求编程显示李先生放在大袋子中的所有商品信息并计算要支付的总价。

  本实例可按安全组合模式设计，其结构图如图 4 所示。

  ![image-20220426105859799](GOF 23种设计模式.assets\image-20220426105859799.png)

- #### 模式的扩展

  如果对前面介绍的组合模式中的树叶节点和树枝节点进行抽象，也就是说树叶节点和树枝节点还有子节点，这时组合模式就扩展成复杂的组合模式了，如 [Java](http://c.biancheng.net/java/) AWT/[Swing](http://c.biancheng.net/swing/) 中的简单组件 JTextComponent 有子类 JTextField、JTextArea，容器组件 Container 也有子类 Window、Panel。复杂的组合模式的结构图如图 5 所示。

  ![image-20220426105940353](GOF 23种设计模式.assets\image-20220426105940353.png)

  

## **行为型设计模式**

行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。

**行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。**由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。

行为型模式是 GoF [设计模式](http://c.biancheng.net/design_pattern/)中最为庞大的一类，它包含以下 11 种模式。

1. 模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
2. 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
3. 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
4. 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。
5. 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。
6. 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
7. 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
8. 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
9. 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。
10. 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
11. 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。


以上 11 种行为型模式，除了模板方法模式和[解释器模式](http://c.biancheng.net/view/1402.html)是类行为型模式，其他的全部属于对象行为型模式，下面我们将详细介绍它们的特点、结构与应用。



### 1.模板方法模式（Template Method）

- #### Intro 简介

  在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。

  例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。

  这样的例子在生活中还有很多，例如，一个人每天会起床、吃饭、做事、睡觉等，其中“做事”的内容每天可能不同。我们把这些规定了流程或格式的实例定义成模板，允许使用者根据自己的需求去更新它，例如，简历模板、论文模板、Word 中模板文件等。

  以下介绍的模板方法模式将解决以上类似的问题。

- #### 模式的定义与特点

  模板方法（Template Method）模式的定义如下：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。

  该模式的主要优点如下。

  1. 它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。
  2. 它在父类中提取了公共的部分代码，便于代码复用。
  3. 部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。

  该模式的主要缺点如下。

  1. 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，间接地增加了系统实现的复杂度。
  2. 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。
  3. 由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有子类都要改一遍。

- #### 模式的应用场景

  模板方法模式通常适用于以下场景。

  1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。
  2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。
  3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。

- #### 模式的结构与实现

  模板方法模式需要注意抽象类与具体子类之间的协作。它用到了虚函数的多态性技术以及“不用调用我，让我来调用你”的反向控制技术。现在来介绍它们的基本结构。

  ##### 1. 模式的结构

  模板方法模式包含以下主要角色。

  **1）抽象类/抽象模板（Abstract Class）**

  抽象模板类，负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。

  ① 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。

  ② 基本方法：是整个算法中的一个步骤，包含以下几种类型。

  - 抽象方法：在抽象类中声明，由具体子类实现。
  - 具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。
  - 钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。

  #### **2）具体子类/具体实现（Concrete Class）**

  具体实现类，实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。

  模板方法模式的结构图如图 1 所示。

  ![image-20220426122003514](GOF 23种设计模式.assets\image-20220426122003514.png)

  ##### 2. 模式的实现

  模式的实现代码如下：

  ```c#
  namespace TemplateMethodPattern;
  
  //抽象类
  internal abstract class AbstractClass
  {
      //模板方法
      public void TemplateMethod()
      {
          Console.WriteLine("-------Begin-------");
          abstractMethod1();
          abstractMethod2();
          Console.WriteLine("-------End-------");
      }
      //抽象方法1
      protected abstract void abstractMethod1();
      //抽象方法1
      protected abstract void abstractMethod2();
  }
  //具体子类
  internal class ConcreteClass : AbstractClass
  {
      protected override void abstractMethod1()
      {
          Console.WriteLine("抽象方法1的实现被调用...");
      }
  
      protected override void abstractMethod2()
      {
          Console.WriteLine("抽象方法2的实现被调用...");
      }
  }
  
  /** Program.cs **/
  AbstractClass c = new ConcreteClass();
  c.TemplateMethod();
  Console.WriteLine();
  /*
  	执行结果：
      -------Begin-------
      抽象方法1的实现被调用...
      抽象方法2的实现被调用...
      -------End-------
  */
  ```

  ##### 3.模式的应用实例

  【例1】用模板方法模式实现出国留学手续设计程序。

  分析：出国留学手续一般经过以下流程：索取学校资料，提出入学申请，办理因私出国护照、出境卡和公证，申请签证，体检、订机票、准备行装，抵达目标学校等，其中有些业务对各个学校是一样的，但有些业务因学校不同而不同，所以比较适合用模板方法模式来实现。

  在本实例中，我们先定义一个出国留学的抽象类 StudyAbroad，里面包含了一个模板方法 TemplateMethod()，该方法中包含了办理出国留学手续流程中的各个基本方法，其中有些方法的处理由于各国都一样，所以在抽象类中就可以实现，但有些方法的处理各国是不同的，必须在其具体子类（如美国留学类 StudyInAmerica）中实现。如果再增加一个国家，只要增加一个子类就可以了，图 2 所示是其结构图。

  ![image-20220426122118113](GOF 23种设计模式.assets\image-20220426122118113.png)

  ```c#
  namespace TemplateMethodPattern;
  //抽象类: 出国留学
  abstract class StudyAbroad
  {
      public void TemplateMethod() //模板方法
      {
          LookingForSchool(); //索取学校资料
          ApplyForEnrol();    //入学申请
          ApplyForPassport(); //办理因私出国护照、出境卡和公证
          ApplyForVisa();     //申请签证
          ReadyGoAbroad();    //体检、订机票、准备行装
          Arriving();         //抵达
      }
      public void ApplyForPassport()
      {
          Console.WriteLine("三.办理因私出国护照、出境卡和公证：");
          Console.WriteLine("  1）持录取通知书、本人户口簿或身份证向户口所在地公安机关申请办理因私出国护照和出境卡。");
          Console.WriteLine("  2）办理出生公证书，学历、学位和成绩公证，经历证书，亲属关系公证，经济担保公证。");
      }
      public void ApplyForVisa()
      {
          Console.WriteLine("四.申请签证：");
          Console.WriteLine("  1）准备申请国外境签证所需的各种资料，包括个人学历、成绩单、工作经历的证明；个人及家庭收入、资金和财产证明；家庭成员的关系证明等；");
          Console.WriteLine("  2）向拟留学国家驻华使(领)馆申请入境签证。申请时需按要求填写有关表格，递交必需的证明材料，缴纳签证。有的国家(比如美国、英国、加拿大等)在申请签证时会要求申请人前往使(领)馆进行面试。");
      }
      public void ReadyGoAbroad()
      {
          Console.WriteLine("五.体检、订机票、准备行装：");
          Console.WriteLine("  1）进行身体检查、免疫检查和接种传染病疫苗；");
          Console.WriteLine("  2）确定机票时间、航班和转机地点。");
      }
      public abstract void LookingForSchool();//索取学校资料
      public abstract void ApplyForEnrol();   //入学申请
      public abstract void Arriving();        //抵达
  }
  //具体子类: 美国留学
  class StudyInAmerica : StudyAbroad
  {
      public override void LookingForSchool()
      {
          Console.WriteLine("一.索取学校以下资料：");
          Console.WriteLine("  1）对留学意向国家的政治、经济、文化背景和教育体制、学术水平进行较为全面的了解；");
          Console.WriteLine("  2）全面了解和掌握国外学校的情况，包括历史、学费、学制、专业、师资配备、教学设施、学术地位、学生人数等；");
          Console.WriteLine("  3）了解该学校的住宿、交通、医疗保险情况如何；");
          Console.WriteLine("  4）该学校在中国是否有授权代理招生的留学中介公司？");
          Console.WriteLine("  5）掌握留学签证情况；");
          Console.WriteLine("  6）该国政府是否允许留学生合法打工？");
          Console.WriteLine("  8）毕业之后可否移民？");
          Console.WriteLine("  9）文凭是否受到我国认可？");
      }
      public override void ApplyForEnrol()
      {
          Console.WriteLine("二.入学申请：");
          Console.WriteLine("  1）填写报名表；");
          Console.WriteLine("  2）将报名表、个人学历证明、最近的学习成绩单、推荐信、个人简历、托福或雅思语言考试成绩单等资料寄往所申请的学校；");
          Console.WriteLine("  3）为了给签证办理留有充裕的时间，建议越早申请越好，一般提前1年就比较从容。");
      }
      public override void Arriving()
      {
          Console.WriteLine("六.抵达目标学校：");
          Console.WriteLine("  1）安排住宿；");
          Console.WriteLine("  2）了解校园及周边环境。");
      }
  }
  /** Program.cs **/
  StudyAbroad tm = new StudyInAmerica();
  tm.TemplateMethod();
  ```

  程序的运行结果如下：

  ```c#
  一.索取学校以下资料：
    1）对留学意向国家的政治、经济、文化背景和教育体制、学术水平进行较为全面的了解；
    2）全面了解和掌握国外学校的情况，包括历史、学费、学制、专业、师资配备、教学设施、学术地位、学生人数等；
    3）了解该学校的住宿、交通、医疗保险情况如何；
    4）该学校在中国是否有授权代理招生的留学中介公司？
    5）掌握留学签证情况；
    6）该国政府是否允许留学生合法打工？
    8）毕业之后可否移民？
    9）文凭是否受到我国认可？
  二.入学申请：
    1）填写报名表；
    2）将报名表、个人学历证明、最近的学习成绩单、推荐信、个人简历、托福或雅思语言考试成绩单等资料寄往所申请的学校；
    3）为了给签证办理留有充裕的时间，建议越早申请越好，一般提前1年就比较从容。
  三.办理因私出国护照、出境卡和公证：
    1）持录取通知书、本人户口簿或身份证向户口所在地公安机关申请办理因私出国护照和出境卡。
    2）办理出生公证书，学历、学位和成绩公证，经历证书，亲属关系公证，经济担保公证。
  四.申请签证：
    1）准备申请国外境签证所需的各种资料，包括个人学历、成绩单、工作经历的证明；个人及家庭收入、资金和财产证明；家庭成员的 关系证明等；
    2）向拟留学国家驻华使(领)馆申请入境签证。申请时需按要求填写有关表格，递交必需的证明材料，缴纳签证。有的国家(比如美国、英国、加拿大等)在申请签证时会要求申请人前往使(领)馆进行面试。
  五.体检、订机票、准备行装：
    1）进行身体检查、免疫检查和接种传染病疫苗；
    2）确定机票时间、航班和转机地点。
  六.抵达目标学校：
    1）安排住宿；
    2）了解校园及周边环境。
  ```

- #### 模式的扩展

  在模板方法模式中，基本方法包含：抽象方法、具体方法和钩子方法，正确使用“钩子方法”可以使得子类控制父类的行为。如下面例子中，可以通过在具体子类中重写钩子方法 HookMethod1() 和 HookMethod2() 来改变抽象父类中的运行结果，其结构图如图 3 所示。

  ![image-20220426122203902](GOF 23种设计模式.assets\image-20220426122203902.png)

  

### 2.策略模式（Strategy）

- #### Intro 简介

  在现实生活中常常遇到实现某种目标存在多种策略可供选择的情况，例如，出行旅游可以乘坐飞机、乘坐火车、骑自行车或自己开私家车等，超市促销可以釆用打折、送商品、送积分等方法。

  在软件开发中也常常遇到类似的情况，当实现某一个功能存在多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能，如数据排序策略有冒泡排序、选择排序、插入排序、二叉树排序等。

  如果使用多重条件转移语句实现（即硬编码），不但使条件语句变得很复杂，而且增加、删除或更换算法要修改原代码，不易维护，违背开闭原则。如果采用策略模式就能很好解决该问题。

- #### 策略模式的定义与特点

  策略（Strategy）模式的定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。

  策略模式的主要优点如下。

  1. 多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句，如 if...else 语句、switch...case 语句。
  2. 策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。
  3. 策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。
  4. 策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。
  5. 策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。

  其主要缺点如下。

  1. 客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。
  2. 策略模式造成很多的策略类，增加维护难度。

- #### 策略模式的应用场景

  策略模式在很多地方用到，如 [Java](http://c.biancheng.net/java/) SE 中的容器布局管理就是一个典型的实例，Java SE 中的每个容器都存在多种布局供用户选择。在程序设计中，通常在以下几种情况中使用策略模式较多。

  1. 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。
  2. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。
  3. 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。
  4. 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的[数据结构](http://c.biancheng.net/data_structure/)。
  5. 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。

- #### 模式的结构与实现

  策略模式是准备一组算法，并将这组算法封装到一系列的策略类里面，作为一个抽象策略类的子类。策略模式的重心不是如何实现算法，而是如何组织这些算法，从而让程序结构更加灵活，具有更好的维护性和扩展性，现在我们来分析其基本结构和实现方法。

  ##### 1. 策略模式的结构

  策略模式的主要角色如下。

  1. 抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。
  2. 具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。
  3. 环境（Context）类：持有一个策略类的引用，最终给客户端调用。

  其结构图如图 1 所示。

  ![image-20220426155959384](GOF 23种设计模式.assets\image-20220426155959384.png)

  ##### 2. 策略模式的实现

  模式的实现代码如下：

  ```c#
  namespace StrategyPattern;
  
  //环境类
  internal class Context
  {
      private readonly Strategy _strategy;
  
      public Context(Strategy strategy) => _strategy = strategy;
  
      public void Implement()
      {
          _strategy.strategyMethod();
      }
  }
  //抽象策略类
  internal abstract class Strategy
  {
      public abstract void strategyMethod();
  }
  //具体策略类A
  internal class ConcreteStrategyA : Strategy
  {
      public override void strategyMethod()
      {
          Console.WriteLine("具体策略A的策略方法被访问！");
      }
  }
  //具体策略类B
  internal class ConcreteStrategyB : Strategy
  {
      public override void strategyMethod()
      {
          Console.WriteLine("具体策略B的策略方法被访问！");
      }
  }
  
  /** Program.cs **/
  var context = new Context(new ConcreteStrategyA());
  context.Implement();
  context = new Context(new ConcreteStrategyB());
  context.Implement();
  /*
  	执行结果：
      具体策略A的策略方法被访问！
      具体策略B的策略方法被访问！
  */
  ```

  ##### 3.策略模式的应用实例

  【例1】策略模式在“大闸蟹”做菜中的应用。

  分析：关于大闸蟹的做法有很多种，我们以清蒸大闸蟹和红烧大闸蟹两种方法为例，介绍策略模式的应用。

  首先，定义一个大闸蟹加工的抽象策略类（CrabCooking），里面包含了一个做菜的抽象方法 CookingMethod()；然后，定义清蒸大闸蟹（SteamedCrabs）和红烧大闸蟹（BraisedCrabs）的具体策略类，它们实现了抽象策略类中的抽象方法；由于本程序要显示做好的结果图（[点此下载要显示的结果图](http://c.biancheng.net/uploads/soft/181113/3-1Q116104147.zip)），所以将具体策略类定义成 JLabel 的子类；最后，定义一个厨房（Kitchen）环境类，它具有设置和选择做菜策略的方法；客户类通过厨房类获取做菜策略，并把做菜结果图在窗体中显示出来，图 2 所示是其结构图。

  ![image-20220426160117215](GOF 23种设计模式.assets\image-20220426160117215.png)

  【例2】用策略模式实现从韶关去婺源旅游的出行方式。

  分析：从韶关去婺源旅游有以下几种出行方式：坐火车、坐汽车和自驾车，所以该实例用策略模式比较适合，图 4 所示是其结构图。

  ![image-20220426160209735](GOF 23种设计模式.assets\image-20220426160209735.png)

  

- #### 策略模式的扩展

  在一个使用策略模式的系统中，当存在的策略很多时，客户端管理所有策略算法将变得很复杂，如果在环境类中使用策略工厂模式来管理这些策略类将大大减少客户端的工作复杂度，其结构图如图 5 所示。

  ![image-20220426160248320](GOF 23种设计模式.assets\image-20220426160248320.png)

  

### 3.命令模式（Command）

- #### Intro 简介

  在软件开发系统中，“方法的请求者”与“方法的实现者”之间经常存在紧密的耦合关系，这不利于软件功能的扩展与维护。例如，想对方法进行“撤销、重做、记录”等处理都很不方便，因此“如何将方法的请求者与实现者解耦？”变得很重要，命令模式就能很好地解决这个问题。

  在现实生活中，命令模式的例子也很多。比如看电视时，我们只需要轻轻一按遥控器就能完成频道的切换，这就是命令模式，将换台请求和换台处理完全解耦了。电视机遥控器（命令发送者）通过按钮（具体命令）来遥控电视机（命令接收者）。

  再比如，我们去餐厅吃饭，菜单不是等到客人来了之后才定制的，而是已经预先配置好的。这样，客人来了就只需要点菜，而不是任由客人临时定制。餐厅提供的菜单就相当于把请求和处理进行了解耦，这就是命令模式的体现。

- #### 模式的定义与特点

  命令（Command）模式的定义如下：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。

  命令模式的主要优点如下。

  1. 通过引入中间件（抽象接口）降低系统的耦合度。
  2. 扩展性良好，增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，且满足“开闭原则”。
  3. 可以实现宏命令。命令模式可以与[组合模式](http://c.biancheng.net/view/1373.html)结合，将多个命令装配成一个组合命令，即宏命令。
  4. 方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的[备忘录模式](http://c.biancheng.net/view/1400.html)结合，实现命令的撤销与恢复。
  5. 可以在现有命令的基础上，增加额外功能。比如日志记录，结合装饰器模式会更加灵活。

  其缺点是：

  1. 可能产生大量具体的命令类。因为每一个具体操作都需要设计一个具体命令类，这会增加系统的复杂性。
  2. 命令模式的结果其实就是接收方的执行结果，但是为了以命令的形式进行架构、解耦请求与实现，引入了额外类型结构（引入了请求方与抽象命令接口），增加了理解上的困难。不过这也是[设计模式](http://c.biancheng.net/design_pattern/)的通病，抽象必然会额外增加类的数量，代码抽离肯定比代码聚合更加难理解。

- #### 模式的应用场景

  当系统的某项操作具备命令语义，且命令实现不稳定（变化）时，可以通过命令模式解耦请求与实现。使用抽象命令接口使请求方的代码架构稳定，封装接收方具体命令的实现细节。接收方与抽象命令呈现弱耦合（内部方法无需一致），具备良好的扩展性。

  命令模式通常适用于以下场景。

  1. 请求调用者需要与请求接收者解耦时，命令模式可以使调用者和接收者不直接交互。
  2. 系统随机请求命令或经常增加、删除命令时，命令模式可以方便地实现这些功能。
  3. 当系统需要执行一组操作时，命令模式可以定义宏命令来实现该功能。
  4. 当系统需要支持命令的撤销（Undo）操作和恢复（Redo）操作时，可以将命令对象存储起来，采用备忘录模式来实现。

- #### 模式的结构与实现

  可以将系统中的相关操作抽象成命令，使调用者与实现者相关分离，其结构如下。

  ##### 1. 模式的结构

  命令模式包含以下主要角色。

  1. 抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()。
  2. 具体命令类（Concrete Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。
  3. 实现者/接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。
  4. 调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。

  其结构图如图 1 所示。

  ![image-20220426163600355](GOF 23种设计模式.assets\image-20220426163600355.png)

  ##### 2. 模式的实现

  模式的实现代码如下：

  ```c#
  namespace CommandPattern;
  
  //调用者
  internal class Invoker
  {
      private Command _command;
  
      public void SetCommand(Command command)
      {
          _command = command;
      }
      public void ExecuteCommand()
      {
          Console.WriteLine("调用者执行命令command...");
          _command.Execute();
      }
  }
  //抽象命令
  internal abstract class Command
  {
      protected readonly Receiver Receiver;
  
      protected Command(Receiver receiver) =>
          Receiver = receiver ?? throw new ArgumentNullException(nameof(receiver));
  
      public abstract void Execute();
  }
  //具体命令
  internal class ConcreteCommand : Command
  {
      public ConcreteCommand(Receiver receiver) : base(receiver)
      {
      }
      public override void Execute()
      {
          Receiver.Action();
      }
  }
  //接收者
  internal class Receiver
  {
      public void Action()
      {
          Console.WriteLine("接收者的action()方法被调用...");
      }
  }
  
  /** Program.cs **/
  Receiver receiver = new Receiver();
  ConcreteCommand command = new ConcreteCommand(receiver);
  Invoker invoker = new Invoker();
  invoker.SetCommand(command);
  invoker.ExecuteCommand();
  Console.WriteLine();
  /*
  	执行结果：
      调用者执行命令command...
      接收者的action()方法被调用...
  */
  ```

  ##### 3.模式的应用实例

  【例1】用命令模式实现客户去餐馆吃早餐的实例。

  分析：客户去餐馆可选择的早餐有肠粉、河粉和馄饨等，客户可向服务员选择以上早餐中的若干种，服务员将客户的请求交给相关的厨师去做。这里的点早餐相当于“命令”，服务员相当于“调用者”，厨师相当于“接收者”，所以用命令模式实现比较合适。

  - 首先，定义一个早餐类（Breakfast），它是抽象命令类，有抽象方法 cooking()，说明要做什么；
  - 再定义其子类肠粉类（ChangFen）、馄饨类（HunTun）和河粉类（HeFen），它们是具体命令类，实现早餐类的 cooking() 方法，但它们不会具体做，而是交给具体的厨师去做；
  - 具体厨师类有肠粉厨师（ChangFenChef）、馄饨厨师（HunTunChef）和河粉厨师（HeFenChef），他们是命令的接收者。


  由于本实例要显示厨师做菜的效果图（[点此下载要显示的效果图](http://c.biancheng.net/uploads/soft/181113/3-1Q116125200.zip)），所以把每个厨师类定义为 JFrame 的子类；最后，定义服务员类（Waiter），它接收客户的做菜请求，并发出做菜的命令。客户类是通过服务员类来点菜的，图 2 所示是其结构图。

  ![image-20220426163652710](GOF 23种设计模式.assets\image-20220426163652710.png)

- #### 模式的扩展

  在软件开发中，有时将命令模式与前面学的组合模式联合使用，这就构成了宏命令模式，也叫组合命令模式。宏命令包含了一组命令，它充当了具体命令与调用者的双重角色，执行它时将递归调用它所包含的所有命令，其具体结构图如图 3 所示。

  ![image-20220426163732708](GOF 23种设计模式.assets\image-20220426163732708.png)

  当然，命令模式还可以同备忘录（Memento）模式组合使用，这样就变成了可撤销的命令模式，这将在后面介绍。




### 4.责任链模式（Chain of Responsibility）

- #### Intro 简介

  在现实生活中，一个事件需要经过多个对象处理是很常见的场景。例如，采购审批流程、请假流程等。公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据需要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这无疑增加了难度。

  在计算机软硬件中也有相关例子，如总线网中数据报传送，每台计算机根据目标地址是否同自己的地址相同来决定是否接收；还有异常处理中，处理程序根据异常的类型决定自己是否处理该异常；还有 [Struts2](http://c.biancheng.net/struts2/) 的拦截器、[JSP](http://c.biancheng.net/jsp/) 和 [Servlet](http://c.biancheng.net/servlet/) 的 Filter 等，所有这些，都可以考虑使用责任链模式来实现。

- #### 模式的定义与特点

  责任链（Chain of Responsibility）模式的定义：为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。

  **注意：责任链模式也叫职责链模式。**

  在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，请求会自动进行传递。所以责任链将请求的发送者和请求的处理者解耦了。

  责任链模式是一种对象行为型模式，其主要优点如下。

  1. 降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。
  2. 增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。
  3. 增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。
  4. 责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。
  5. 责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。

  其主要缺点如下。

  1. 不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。
  2. 对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。
  3. 职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。

- #### 模式的应用场景

  前边已经讲述了关于责任链模式的结构与特点，下面介绍其应用场景，责任链模式通常在以下几种情况使用。

  1. 多个对象可以处理一个请求，但具体由哪个对象处理该请求在运行时自动确定。
  2. 可动态指定一组对象处理请求，或添加新的处理者。
  3. 需要在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求。

- #### 模式的结构与实现

  通常情况下，可以通过数据链表来实现职责链模式的[数据结构](http://c.biancheng.net/data_structure/)。

  ##### 1. 模式的结构

  - 职责链模式主要包含以下角色。

    1. 抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。
    2. 具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。
    3. 客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。


  责任链模式的本质是解耦请求与处理，让请求在处理链中能进行传递与被处理；理解责任链模式应当理解其模式，而不是其具体实现。责任链模式的独到之处是将其节点处理者组合成了链式结构，并允许节点自身决定是否进行请求处理或转发，相当于让请求流动起来。

  其结构图如图 1 所示。客户端可按图 2 所示设置责任链。

  ![image-20220426211656581](GOF 23种设计模式.assets\image-20220426211656581.png)

  ![image-20220426211737547](GOF 23种设计模式.assets\image-20220426211737547.png)

  **2.模式的实现**

  模式的实现代码如下：

  ```c#
  namespace ChainOfResponsibilityPattern;
  
  //抽象处理者角色
  internal abstract class Handler
  {
      protected Handler next;
  
      public void SetNext(Handler next)
      {
          this.next = next;
      }
  
      public abstract void HandleRequest(string request);
  }
  //具体处理者角色1
  internal class ConcreteHandler1 : Handler
  {
      public override void HandleRequest(string request)
      {
          if (request.Equals("one"))
          {
              Console.WriteLine($"{GetType().Name} 处理该请求{request}");
          }
          else
          {
              this.next?.HandleRequest(request);
  
          }
      }
  }
  //具体处理者角色2
  internal class ConcreteHandler2 : Handler
  {
  
      public override void HandleRequest(string request)
      {
          if (request.Equals("two"))
          {
              Console.WriteLine($"{GetType().Name} 处理该请求{request}");
          }
          else
          {
              if (this.next != null)
              {
                  this.next?.HandleRequest(request);
              }
              else
              {
                  Console.WriteLine("没有人处理该请求！");
              }
              //this.next?.HandleRequest(request);
          }
      }
  }
  
  /** Program.cs **/
  //组装责任链
  Handler handler1 = new ConcreteHandler1();
  Handler handler2 = new ConcreteHandler2();
  handler1.SetNext(handler2);
  //提交请求
  handler1.HandleRequest("one");
  handler1.HandleRequest("two");
  
  /*
  	执行结果：
      ConcreteHandler1 处理该请求one
      ConcreteHandler2 处理该请求two
  */
  ```

  **3.模式的应用实例**

  【例1】用责任链模式设计一个请假条审批模块。

   分析：假如规定学生请假小于或等于 2 天，班主任可以批准；小于或等于 7 天，系主任可以批准；小于或等于 10 天，院长可以批准；其他情况不予批准；这个实例适合使用职责链模式实现。

  首先，定义一个领导类（Leader），它是抽象处理者，包含了一个指向下一位领导的指针 next 和一个处理假条的抽象处理方法 handleRequest(int LeaveDays)；然后，定义班主任类（ClassAdviser）、系主任类（DepartmentHead）和院长类（Dean），它们是抽象处理者的子类，是具体处理者，必须根据自己的权力去实现父类的 handleRequest(int LeaveDays) 方法，如果无权处理就将假条交给下一位具体处理者，直到最后；客户类负责创建处理链，并将假条交给链头的具体处理者（班主任）。图 3 所示是其结构图。

  ![image-20220426211820462](GOF 23种设计模式.assets\image-20220426211820462.png)

  ```c#
  namespace ChainOfResponsibilityPattern;
  
  //抽象处理者：领导类
  internal abstract class Leader
  {
      protected readonly string LeaderName;
      protected Leader next;
  
      protected Leader(string leaderName) => LeaderName = leaderName;
  
      public void setNext(Leader next)
      {
          this.next = next;
      }
  
      public abstract void handleRequest(Request request);
  }
  
  //具体处理者1：班主任类
  internal class ClassAdviser : Leader
  {
      public ClassAdviser(string LeaderName) : base(LeaderName)
      {
      }
  
      public override void handleRequest(Request request)
      {
          if (request.RequestType == "请假" && request.RequestNum <= 2)
          {
              Console.WriteLine($"{LeaderName }: {request.RequestContent} {request.RequestNum}天被批准");
          }
          else
          {
              Console.WriteLine($"{LeaderName }: 权限不够");
              this.next?.handleRequest(request);
          }
      }
  }
  //具体处理者2：系主任类
  internal class DepartmentHead : Leader
  {
      public DepartmentHead(string LeaderName) : base(LeaderName)
      {
      }
  
      public override void handleRequest(Request request)
      {
          if (request.RequestType == "请假" && request.RequestNum <= 7)
          {
              Console.WriteLine($"{LeaderName}: {request.RequestContent} {request.RequestNum}天被批准");
          }
          else
          {
              Console.WriteLine($"{LeaderName }: 权限不够");
              this.next?.handleRequest(request);
          }
      }
  }
  //具体处理者3：院长类
  internal class Dean : Leader
  {
      public Dean(string LeaderName) : base(LeaderName)
      {
      }
  
      public override void handleRequest(Request request)
      {
          if (request.RequestType == "请假" && request.RequestNum <= 10)
          {
              Console.WriteLine($"{LeaderName}: {request.RequestContent} {request.RequestNum}天被批准");
          }
          else
          {
              Console.WriteLine($"{LeaderName }: 权限不够");
              this.next?.handleRequest(request);
          }
      }
  }
  //具体处理者4：教务处长类
  internal class DeanOfStudies : Leader
  {
      public DeanOfStudies(string LeaderName) : base(LeaderName)
      {
      }
  
      public override void handleRequest(Request request)
      {
          if (request.RequestType == "请假")
          {
              Console.WriteLine($"{LeaderName}: {request.RequestContent} {request.RequestNum}天被批准");
              return;
          }
          if (request.RequestType == "加薪" && request.RequestNum <= 500)
          {
              Console.WriteLine($"{LeaderName}: {request.RequestContent} 数量{request.RequestNum}被批准");
              return;
          }
          if (request.RequestType == "加薪" && request.RequestNum > 500)
          {
              Console.WriteLine($"{LeaderName}: {request.RequestContent} {request.RequestNum}，再说吧");
          }
          else { Console.WriteLine("没有人处理该请求！"); }
      }
  }
  
  
  /** Model.cs **/
  namespace ChainOfResponsibilityPattern;
  
  internal class Request
  {
      public string RequestType { get; set; }
  
      public string RequestContent { get; set; }
  
      public int RequestNum { get; set; }
  }
  
  /** Program.cs **/
  {
      //组装责任链
      var manager = new ClassAdviser("班主任");
      var manager1 = new DepartmentHead("系主任");
      var manager2 = new Dean("院长");
      var manager3 = new DeanOfStudies("教务处长");
  
      manager.setNext(manager1);
      manager1.setNext(manager2);
      manager2.setNext(manager3);
  
      //提交请求
      var request = new Request()
      {
          RequestNum = 1,
          RequestType = "请假",
          RequestContent = "小菜请假"
      };
      manager.handleRequest(request);
  
      var request1 = new Request()
      {
          RequestNum = 7,
          RequestType = "请假",
          RequestContent = "小菜请假"
      };
      manager.handleRequest(request1);
  
      var request2 = new Request()
      {
          RequestNum = 500,
          RequestType = "加薪",
          RequestContent = "小菜请求加薪"
      };
      manager.handleRequest(request2);
  
      var request3 = new Request()
      {
          RequestNum = 1000,
          RequestType = "加薪",
          RequestContent = "小菜请求加薪"
      };
      manager.handleRequest(request3);
  }
  /*
  	执行结果：
     	班主任: 小菜请假 1天被批准
      班主任: 权限不够
      系主任: 小菜请假 7天被批准
      班主任: 权限不够
      系主任: 权限不够
      院长: 权限不够
      教务处长: 小菜请求加薪 数量500被批准
      班主任: 权限不够
      系主任: 权限不够
      院长: 权限不够
      教务处长: 小菜请求加薪 1000，再说吧
  */
  ```

  

- #### 模式的扩展

  职责链模式存在以下两种情况。

  1. 纯的职责链模式：一个请求必须被某一个处理者对象所接收，且一个具体处理者对某个请求的处理只能采用以下两种行为之一：自己处理（承担责任）；把责任推给下家处理。
  2. 不纯的职责链模式：允许出现某一个具体处理者对象在承担了请求的一部分责任后又将剩余的责任传给下家的情况，且一个请求可以最终不被任何接收端对象所接收。



### 5.状态模式（State）

- #### Intro 简介

  在软件开发过程中，应用程序中的部分对象可能会根据不同的情况做出不同的行为，我们把这种对象称为有状态的对象，而把影响对象行为的一个或多个动态变化的属性称为状态。当有状态的对象与外部事件产生互动时，其内部状态就会发生改变，从而使其行为也发生改变。如人都有高兴和伤心的时候，不同的情绪有不同的行为，当然外界也会影响其情绪变化。

  对这种有状态的对象编程，传统的解决方案是：将这些所有可能发生的情况全都考虑到，然后使用 if-else 或 switch-case 语句来做状态判断，再进行不同情况的处理。但是显然这种做法对复杂的状态判断存在天然弊端，条件判断语句会过于臃肿，可读性差，且不具备扩展性，维护难度也大。且增加新的状态时要添加新的 if-else 语句，这违背了“开闭原则”，不利于程序的扩展。

  以上问题如果采用“状态模式”就能很好地得到解决。状态模式的解决思想是：当控制一个对象状态转换的条件表达式过于复杂时，把相关“判断逻辑”提取出来，用各个不同的类进行表示，系统处于哪种情况，直接使用相应的状态类对象进行处理，这样能把原来复杂的逻辑判断简单化，消除了 if-else、switch-case 等冗余语句，代码更有层次性，并且具备良好的扩展力。

- #### 模式的定义与特点

  状态（State）模式的定义：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。

  状态模式是一种对象行为型模式，其主要优点如下。

  1. 结构清晰，状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。
  2. 将状态转换显示化，减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。
  3. 状态类职责明确，有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。

  状态模式的主要缺点如下。

  1. 状态模式的使用必然会增加系统的类与对象的个数。
  2. 状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。
  3. 状态模式对开闭原则的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源码，否则无法切换到新增状态，而且修改某个状态类的行为也需要修改对应类的源码。

- #### 模式的应用场景

  通常在以下情况下可以考虑使用状态模式。

  - 当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。
  - 一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。

- #### 模式的结构与实现

  状态模式把受环境改变的对象行为包装在不同的状态对象里，其意图是让一个对象在其内部状态改变的时候，其行为也随之改变。现在我们来分析其基本结构和实现方法。

  ##### 1. 模式的结构

  状态模式包含以下主要角色。

  1. 环境类（Context）角色：也称为上下文，它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换。
  2. 抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为，可以有一个或多个行为。
  3. 具体状态（Concrete State）角色：实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。

  其结构图如图 1 所示。

  ![image-20220427113031185](GOF 23种设计模式.assets\image-20220427113031185.png)

  ##### 2. 模式的实现

  模式的实现代码如下：

  ```c#
  namespace StatePattern;
  
  //环境类
  internal class Context
  {
      private State _state;
  
      //定义环境类的初始状态
      public Context(State state) => _state = state;
  
      //设置新状态
      public State State
      {
          get => _state;
          set
          {
              _state = value;
              Console.WriteLine($"当前状态：{_state.GetType().Name}");
          }
      }
      //对请求做处理
      public void Request()
      {
          _state.Handle(this);
      }
  }
  //抽象状态类
  internal abstract class State
  {
      public abstract void Handle(Context context);
  }
  //具体状态A类
  internal class ConcreteStateA : State
  {
      public override void Handle(Context context)
      {
          context.State = new ConcreteStateB(); //设置 ConcreteStateA 的下一状态是 ConcreteStateB
      }
  }
  //具体状态B类
  internal class ConcreteStateB : State
  {
      public override void Handle(Context context)
      {
          context.State = new ConcreteStateA();//设置 ConcreteStateB 的下一状态是 ConcreteStateA
      }
  }
  
  /** Program.cs **/
  {
      var context = new Context(new ConcreteStateA());
      context.Request();
      context.Request();
      context.Request();
      context.Request();
  }
  /*
  	执行结果：
      当前状态：ConcreteStateB
      当前状态：ConcreteStateA
      当前状态：ConcreteStateB
      当前状态：ConcreteStateA
  */
  ```

  ##### 3.模式的应用实例

  【例1】用“状态模式”设计一个学生成绩的状态转换程序。

  分析：本实例包含了“不及格”“中等”和“优秀” 3 种状态，当学生的分数小于 60 分时为“不及格”状态，当分数大于等于 60 分且小于 90 分时为“中等”状态，当分数大于等于 90 分时为“优秀”状态，我们用状态模式来实现这个程序。

  首先，定义一个抽象状态类（AbstractState），其中包含了环境属性、状态名属性和当前分数属性，以及加减分方法 addScore(intx) 和检查当前状态的抽象方法 checkState()。

  然后，定义“不及格”状态类 LowState、“中等”状态类 MiddleState 和“优秀”状态类 HighState，它们是具体状态类，实现 checkState() 方法，负责检査自己的状态，并根据情况转换。

  最后，定义环境类（ScoreContext），其中包含了当前状态对象和加减分的方法 add(int score)，客户类通过该方法来改变成绩状态。图 2 所示是其结构图。

  ![image-20220427113101876](GOF 23种设计模式.assets\image-20220427113101876.png)

  【例2】用“状态模式”设计一个多线程的状态转换程序。

  分析：多线程存在 5 种状态，分别为新建状态、就绪状态、运行状态、阻塞状态和死亡状态，各个状态当遇到相关方法调用或事件触发时会转换到其他状态，其状态转换规律如图 3 所示。

  ![image-20220427113201293](GOF 23种设计模式.assets\image-20220427113201293.png)

  现在先定义一个抽象状态类（TheadState），然后为图 3 所示的每个状态设计一个具体状态类，它们是新建状态（New）、就绪状态（Runnable ）、运行状态（Running）、阻塞状态（Blocked）和死亡状态（Dead），每个状态中有触发它们转变状态的方法，环境类（ThreadContext）中先生成一个初始状态（New），并提供相关触发方法，图 4 所示是线程状态转换程序的结构图。

  ![image-20220427113223757](GOF 23种设计模式.assets\image-20220427113223757.png)

- #### 模式的扩展

  在有些情况下，可能有多个环境对象需要共享一组状态，这时需要引入享元模式，将这些具体状态对象放在集合中供程序共享，其结构图如图 5 所示。

  ![image-20220427113313711](GOF 23种设计模式.assets\image-20220427113313711.png)

  分析：共享状态模式的不同之处是在环境类中增加了一个 HashMap 来保存相关状态，当需要某种状态时可以从中获取，其程序代码如下：

  ```c#
  
  ```

  #### 状态模式与责任链模式的区别

  状态模式和责任链模式都能消除 if-else 分支过多的问题。但在某些情况下，状态模式中的状态可以理解为责任，那么在这种情况下，两种模式都可以使用。

  从定义来看，状态模式强调的是一个对象内在状态的改变，而责任链模式强调的是外部节点对象间的改变。

  从代码实现上来看，两者最大的区别就是状态模式的各个状态对象知道自己要进入的下一个状态对象，而责任链模式并不清楚其下一个节点处理对象，因为链式组装由客户端负责。

  #### 状态模式与策略模式的区别

  状态模式和策略模式的 UML 类图架构几乎完全一样，但两者的应用场景是不一样的。策略模式的多种算法行为择其一都能满足，彼此之间是独立的，用户可自行更换策略算法，而状态模式的各个状态间存在相互关系，彼此之间在一定条件下存在自动切换状态的效果，并且用户无法指定状态，只能设置初始状态。

  


### 6.观察者模式（Observer）

- #### Intro 简介

  在现实世界中，许多对象并不是独立存在的，其中一个对象的行为发生改变可能会导致一个或者多个其他对象的行为也发生改变。例如，某种商品的物价上涨时会导致部分商家高兴，而消费者伤心；还有，当我们开车到交叉路口时，遇到红灯会停，遇到绿灯会行。这样的例子还有很多，例如，股票价格与股民、微信公众号与微信用户、气象局的天气预报与听众、小偷与警察等。

  在软件世界也是这样，例如，Excel 中的数据与折线图、饼状图、柱状图之间的关系；MVC 模式中的模型与视图的关系；事件模型中的事件源与事件处理者。所有这些，如果用观察者模式来实现就非常方便。

- #### 观察者模式的定义与特点

  观察者（Observer）模式的定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。**这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。**

  观察者模式是一种对象行为型模式，其主要优点如下。

  1. 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则。
  2. 目标与观察者之间建立了一套触发机制。

  它的主要缺点如下。

  1. 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。
  2. 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。

- #### 观察者模式的应用场景

  在软件系统中，当系统一方行为依赖另一方行为的变动时，可使用观察者模式松耦合联动双方，使得一方的变动可以通知到感兴趣的另一方对象，从而让另一方对象对此做出响应。

  通过前面的分析与应用实例可知观察者模式适合以下几种情形。

  1. 对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。
  2. 当一个抽象模型有两个方面，其中一个方面依赖于另一方面时，可将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。
  3. 实现类似广播机制的功能，不需要知道具体收听者，只需分发广播，系统中感兴趣的对象会自动接收该广播。
  4. 多层级嵌套使用，形成一种链式触发机制，使得事件具备跨域（跨越两种观察者类型）通知。

- #### 观察者模式的结构与实现

  实现观察者模式时要注意具体目标对象和具体观察者对象之间不能直接调用，否则将使两者之间紧密耦合起来，这违反了面向对象的设计原则。

  ##### 1. 观察者模式的结构

  观察者模式的主要角色如下。

  1. 抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。
  2. 具体主题（Concrete Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。
  3. 抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。
  4. 具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。

  观察者模式的结构图如图 1 所示。

  ![image-20220427143114169](GOF 23种设计模式.assets\image-20220427143114169.png)

  ##### 2. 观察者模式的实现

  模式的实现代码如下：

  ```c#
  namespace ObserverPattern;
  //抽象目标
  abstract class Subject
  {
      protected List<IObserver> observers = new List<IObserver> ();
      //增加观察者方法
      public void add(IObserver iObserver)
      {
          observers.Add(iObserver);
      }
      //删除观察者方法
      public void remove(IObserver iObserver)
      {
          observers.Remove(iObserver);
      }
      public abstract void notifyObserver(); //通知观察者方法
  }
  //具体目标
  class ConcreteSubject : Subject
  {
      public override void notifyObserver()
      {
          Console.WriteLine("具体目标发生改变...");
          Console.WriteLine("--------------");
  
          foreach (IObserver iObserver in observers)
          {
              iObserver.response();
          }
      }
  }
  //抽象观察者
  interface IObserver
  {
      void response(); //反应
  }
  //具体观察者1
  class ConcreteObserver1 : IObserver
  {
      public void response()
      {
          Console.WriteLine("具体观察者1作出反应！");
      }
  }
  //具体观察者1
  class ConcreteObserver2 : IObserver
  {
      public void response()
      {
          Console.WriteLine("具体观察者2作出反应！");
      } 
  }
  
  /** Program.cs **/
      Subject subject = new ConcreteSubject();
      IObserver obs1 = new ConcreteObserver1();
      IObserver obs2 = new ConcreteObserver2();
      subject.add(obs1);
      subject.add(obs2);
      subject.notifyObserver();
      Console.WriteLine();
  /*
  	执行结果：
      具体目标发生改变...
      --------------
      具体观察者1作出反应！
      具体观察者2作出反应！
  */
  ```

  ##### 3.观察者模式的应用实例

  【例1】利用观察者模式设计一个程序，分析“人民币汇率”的升值或贬值对进口公司进口产品成本或出口公司的出口产品收入以及公司利润率的影响。

  分析：当“人民币汇率”升值时，进口公司的进口产品成本降低且利润率提升，出口公司的出口产品收入降低且利润率降低；当“人民币汇率”贬值时，进口公司的进口产品成本提升且利润率降低，出口公司的出口产品收入提升且利润率提升。

  这里的汇率（Rate）类是抽象目标类，它包含了保存观察者（Company）的 List 和增加/删除观察者的方法，以及有关汇率改变的抽象方法 change(int number)；而人民币汇率（RMBrate）类是具体目标， 它实现了父类的 change(int number) 方法，即当人民币汇率发生改变时通过相关公司；公司（Company）类是抽象观察者，它定义了一个有关汇率反应的抽象方法 response(int number)；进口公司（ImportCompany）类和出口公司（ExportCompany）类是具体观察者类，它们实现了父类的 response(int number) 方法，即当它们接收到汇率发生改变的通知时作为相应的反应。图 2 所示是其结构图。

  ![image-20220427143239709](GOF 23种设计模式.assets\image-20220427143239709.png)

  ```c#
  
  ```

  观察者模式在软件幵发中用得最多的是窗体程序设计中的事件处理，窗体中的所有组件都是“事件源”，也就是目标对象，而事件处理程序类的对象是具体观察者对象。下面以一个学校铃声的事件处理程序为例，介绍 Windows 中的“事件处理模型”的工作原理。

  【例2】利用观察者模式设计一个学校铃声的事件处理程序。

  分析：在本实例中，学校的“铃”是事件源和目标，“老师”和“学生”是事件监听器和具体观察者，“铃声”是事件类。学生和老师来到学校的教学区，都会注意学校的铃，这叫事件绑定；当上课时间或下课时间到，会触发铃发声，这时会生成“铃声”事件；学生和老师听到铃声会开始上课或下课，这叫事件处理。这个实例非常适合用观察者模式实现，图 3 给出了学校铃声的事件模型。

  现在用“观察者模式”来实现该事件处理模型。

  ![image-20220427143334446](GOF 23种设计模式.assets\image-20220427143334446.png)

  首先，定义一个铃声事件（RingEvent）类，它记录了铃声的类型（上课铃声/下课铃声）。

  再定义一个学校的铃（BellEventSource）类，它是事件源，是观察者目标类，该类里面包含了监听器容器 listener，可以绑定监听者（学生或老师），并且有产生铃声事件和通知所有监听者的方法。

  然后，定义铃声事件监听者（BellEventListener）类，它是抽象观察者，它包含了铃声事件处理方法 heardBell(RingEvent e)。

  最后，定义老师类（TeachEventListener）和学生类（StuEventListener），它们是事件监听器，是具体观察者，听到铃声会去上课或下课。图 4 给出了学校铃声事件处理程序的结构。

  ![image-20220427143403724](GOF 23种设计模式.assets\image-20220427143403724.png)

- #### 观察者模式的扩展

  在 [Java](http://c.biancheng.net/java/) 中，通过 java.util.Observable 类和 java.util.Observer 接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例。
  
  #### 1. Observable类
  
  Observable 类是抽象目标类，它有一个 Vector 向量，用于保存所有要通知的观察者对象，下面来介绍它最重要的 3 个方法。
  
  1. void addObserver(Observer o) 方法：用于将新的观察者对象添加到向量中。
  2. void notifyObservers(Object arg) 方法：调用向量中的所有观察者对象的 update() 方法，通知它们数据发生改变。通常越晚加入向量的观察者越先得到通知。
  3. void setChange() 方法：用来设置一个 boolean 类型的内部标志位，注明目标对象发生了变化。当它为真时，notifyObservers() 才会通知观察者。
  
  #### 2. Observer 接口
  
  Observer 接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用 void update(Observable o,Object arg) 方法，进行相应的工作。
  
  【例3】利用 Observable 类和 Observer 接口实现原油期货的观察者模式实例。
  
  分析：当原油价格上涨时，空方伤心，多方局兴；当油价下跌时，空方局兴，多方伤心。本实例中的抽象目标（Observable）类在 Java 中已经定义，可以直接定义其子类，即原油期货（OilFutures）类，它是具体目标类，该类中定义一个 SetPriCe(float price) 方法，当原油数据发生变化时调用其父类的 notifyObservers(Object arg) 方法来通知所有观察者；另外，本实例中的抽象观察者接口（Observer）在 Java 中已经定义，只要定义其子类，即具体观察者类（包括多方类 Bull 和空方类 Bear），并实现 update(Observable o,Object arg) 方法即可。图 5 所示是其结构图。
  
  ![image-20220427143458992](GOF 23种设计模式.assets\image-20220427143458992.png)
  
  

### 7.中介者模式（Mediator）

- #### Intro 简介

  在现实生活中，常常会出现好多对象之间存在复杂的交互关系，这种交互关系常常是“网状结构”，它要求每个对象都必须知道它需要交互的对象。例如，每个人必须记住他（她）所有朋友的电话；而且，朋友中如果有人的电话修改了，他（她）必须让其他所有的朋友一起修改，这叫作“牵一发而动全身”，非常复杂。

  如果把这种“网状结构”改为“星形结构”的话，将大大降低它们之间的“耦合性”，这时只要找一个“中介者”就可以了。如前面所说的“每个人必须记住所有朋友电话”的问题，只要在网上建立一个每个朋友都可以访问的“通信录”就解决了。这样的例子还有很多，例如，你刚刚参加工作想租房，可以找“房屋中介”；或者，自己刚刚到一个陌生城市找工作，可以找“人才交流中心”帮忙。

  在软件的开发过程中，这样的例子也很多，例如，在 MVC 框架中，控制器（C）就是模型（M）和视图（V）的中介者；还有大家常用的 QQ 聊天程序的“中介者”是 QQ 服务器。所有这些，都可以采用“中介者模式”来实现，它将大大降低对象之间的耦合性，提高系统的灵活性。

- #### 模式的定义与特点

  中介者（Mediator）模式的定义：定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。

  中介者模式是一种对象行为型模式，其主要优点如下。

  1. 类之间各司其职，符合迪米特法则。
  2. 降低了对象之间的耦合性，使得对象易于独立地被复用。
  3. 将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。

  其主要缺点是：中介者模式将原本多个对象直接的相互依赖变成了中介者和多个同事类的依赖关系。当同事类越多时，中介者就会越臃肿，变得复杂且难以维护。

- #### 模式的应用场景

  前面分析了中介者模式的结构与特点，下面分析其以下应用场景。

  - 当对象之间存在复杂的网状结构关系而导致依赖关系混乱且难以复用时。
  - 当想创建一个运行于多个类之间的对象，又不想生成新的子类时。

- #### 模式的结构与实现

  中介者模式实现的关键是找出“中介者”，下面对它的结构和实现进行分析。

  ##### 1. 模式的结构

  中介者模式包含以下主要角色。

  1. 抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。
  2. 具体中介者（Concrete Mediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。
  3. 抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。
  4. 具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。

  中介者模式的结构图如图 1 所示。

  ![image-20220427143728815](GOF 23种设计模式.assets\image-20220427143728815.png)

  ##### 2. 模式的实现

  模式的实现代码如下：

  ```c#
  namespace MediatorPattern;
  //抽象中介者
  abstract class Mediator
  {
      public abstract void register(Colleague colleague);
      public abstract void relay(Colleague cl); //转发
  }
  //具体中介者
  class ConcreteMediator : Mediator
  {
      private List<Colleague> colleagues = new List<Colleague>();
      public override void register(Colleague colleague)
      {
          if (!colleagues.Contains(colleague))
          {
              colleagues.Add(colleague);
              colleague.setMedium(this);
          }
      }
      public override void relay(Colleague cl)
      {
          foreach (Colleague colleague in colleagues)
          {
              if (!colleague.Equals(cl))
              {
                  ((Colleague)colleague).receive();
              }
          }
      }
  }
  //抽象同事类
  abstract class Colleague
  {
      protected Mediator mediator;
      public void setMedium(Mediator mediator)
      {
          this.mediator = mediator;
      }
      public abstract void receive();
      public abstract void send();
  }
  //具体同事类
  class ConcreteColleague1 : Colleague
  {
      public override void receive()
      {
          Console.WriteLine("具体同事类1收到请求。");
      }
      public override void send()
      {
          Console.WriteLine("具体同事类1发出请求。");
          mediator.relay(this); //请中介者转发
      }
  }
  //具体同事类
  class ConcreteColleague2 : Colleague
  {
      public override void receive()
      {
          Console.WriteLine("具体同事类2收到请求。");
      }
      public override void send()
      {
          Console.WriteLine("具体同事类2发出请求。");
          mediator.relay(this); //请中介者转发
      }
  }
  
  /** Program.cs **/
      Mediator md = new ConcreteMediator();
      Colleague c1 = new ConcreteColleague1();
      Colleague c2 = new ConcreteColleague2();
      md.register(c1);
      md.register(c2);
      c1.send();
      Console.WriteLine("-------------");
      c2.send();
  /*
      具体同事类1发出请求。
      具体同事类2收到请求。
      -------------
      具体同事类2发出请求。
      具体同事类1收到请求。
  */
  ```

  ##### 3.模式的应用实例

  【例1】用中介者模式编写一个“韶关房地产交流平台”程序。

  说明：韶关房地产交流平台是“房地产中介公司”提供给“卖方客户”与“买方客户”进行信息交流的平台，比较适合用中介者模式来实现。

  首先，定义一个中介公司（Medium）接口，它是抽象中介者，它包含了客户注册方法 register(Customer member) 和信息转发方法 relay(String from,String ad)；再定义一个韶关房地产中介（EstateMedium）公司，它是具体中介者类，它包含了保存客户信息的 List 对象，并实现了中介公司中的抽象方法。

  然后，定义一个客户（Customer）类，它是抽象同事类，其中包含了中介者的对象，和发送信息的 send(String ad) 方法与接收信息的 receive(String from，String ad) 方法的接口，由于本程序是窗体程序，所以本类继承 JPmme 类，并实现动作事件的处理方法 actionPerformed(ActionEvent e)。

  最后，定义卖方（Seller）类和买方（Buyer）类，它们是具体同事类，是客户（Customer）类的子类，它们实现了父类中的抽象方法，通过中介者类进行信息交流，其结构图如图 2 所示。

  ![image-20220427143811252](GOF 23种设计模式.assets\image-20220427143811252.png)

- #### 模式的扩展

  在实际开发中，通常采用以下两种方法来简化中介者模式，使开发变得更简单。
  
  1. 不定义中介者接口，把具体中介者对象实现成为单例。
  2. 同事对象不持有中介者，而是在需要的时候直接获取中介者对象并调用。
  
  图 4 所示是简化中介者模式的结构图。
  
  ![image-20220427143926468](GOF 23种设计模式.assets\image-20220427143926468.png)
  
  

### 8.迭代器模式（Iterator）

- #### Intro 简介

  在现实生活以及程序设计中，经常要访问一个聚合对象中的各个元素，如“[数据结构](http://c.biancheng.net/data_structure/)”中的链表遍历，通常的做法是将链表的创建和遍历都放在同一个类中，但这种方式不利于程序的扩展，如果要更换遍历方法就必须修改程序源代码，这违背了 “开闭原则”。

  既然将遍历方法封装在聚合类中不可取，那么聚合类中不提供遍历方法，将遍历方法由用户自己实现是否可行呢？答案是同样不可取，因为这种方式会存在两个缺点：

  1. 暴露了聚合类的内部表示，使其数据不安全；
  2. 增加了客户的负担。

  “迭代器模式”能较好地克服以上缺点，它在客户访问类与聚合类之间插入一个迭代器，这分离了聚合对象与其遍历行为，对客户也隐藏了其内部细节，且满足“单一职责原则”和“开闭原则”，如 [Java](http://c.biancheng.net/java/) 中的 Collection、List、Set、Map 等都包含了迭代器。

  迭代器模式在生活中应用的比较广泛，比如：物流系统中的传送带，不管传送的是什么物品，都会被打包成一个个箱子，并且有一个统一的二维码。这样我们不需要关心箱子里是什么，在分发时只需要一个个检查发送的目的地即可。再比如，我们平时乘坐交通工具，都是统一刷卡或者刷脸进站，而不需要关心是男性还是女性、是残疾人还是正常人等信息。

- #### 模式的定义与特点

  迭代器（Iterator）模式的定义：提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。迭代器模式是一种对象行为型模式，其主要优点如下。

  1. 访问一个聚合对象的内容而无须暴露它的内部表示。
  2. 遍历任务交由迭代器完成，这简化了聚合类。
  3. 它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。
  4. 增加新的聚合类和迭代器类都很方便，无须修改原有代码。
  5. 封装性良好，为遍历不同的聚合结构提供一个统一的接口。

  其主要缺点是：增加了类的个数，这在一定程度上增加了系统的复杂性。

  在日常开发中，我们几乎不会自己写迭代器。除非需要定制一个自己实现的数据结构对应的迭代器，否则，开源框架提供的 API 完全够用。

- #### 模式的应用场景

  前面介绍了关于迭代器模式的结构与特点，下面介绍其应用场景，迭代器模式通常在以下几种情况使用。

  1. 当需要为聚合对象提供多种遍历方式时。
  2. 当需要为遍历不同的聚合结构提供一个统一的接口时。
  3. 当访问一个聚合对象的内容而无须暴露其内部细节的表示时。

  由于聚合与迭代器的关系非常密切，所以大多数语言在实现聚合类时都提供了迭代器类，因此大数情况下使用语言中已有的聚合类的迭代器就已经够了。

- #### 模式的结构与实现

  迭代器模式是通过将聚合对象的遍历行为分离出来，抽象成迭代器类来实现的，其目的是在不暴露聚合对象的内部结构的情况下，让外部代码透明地访问聚合的内部数据。现在我们来分析其基本结构与实现方法。

  ##### 1. 模式的结构

  迭代器模式主要包含以下角色。

  1. 抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。
  2. 具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。
  3. 抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。
  4. 具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。

  其结构图如图 1 所示。

  ![image-20220427144241928](GOF 23种设计模式.assets\image-20220427144241928.png)

  ##### 2. 模式的实现

  模式的实现代码如下：

  ```c#
  namespace IteratorPattern;
  //抽象聚合
  interface IAggregate
  {
      public void add(Object obj);
      public void remove(Object obj);
      public Iterator getIterator();
  }
  //具体聚合
  class ConcreteAggregate : IAggregate
  {
      private List<Object> list = new List<object>();
      public void add(Object obj)
      {
          list.Add(obj);
      }
      public void remove(Object obj)
      {
          list.Remove(obj);
      }
      public Iterator getIterator()
      {
          return new ConcreteIterator(list);
      }
  }
  //抽象迭代器
  interface Iterator
  {
      Object first();
      Object next();
      Boolean hasNext();
  }
  //具体迭代器
  class ConcreteIterator : Iterator
  {
      private List<Object> list = null;
      private int index = -1;
      public ConcreteIterator(List<Object> list)
      {
          this.list = list;
      }
      public Object first()
      {
          index = 0;
          Object obj = list[index];
          return obj;
      }
      public Object next()
      {
          Object obj = null;
          if (this.hasNext())
          {
              obj = list[++index];
          }
          return obj;
      }
      public Boolean hasNext()
      {
          if (index < list.Count() - 1)
          {
              return true;
          }
          else
          {
              return false;
          }
      }
  }
  
  /** Program.cs **/
      IAggregate ag = new ConcreteAggregate();
      ag.add("中山大学");
      ag.add("华南理工");
      ag.add("韶关学院");
      Console.WriteLine("聚合的内容有：");
      Iterator it = ag.getIterator();
      while (it.hasNext())
      {
          Console.WriteLine(it.next().ToString() + "\t");
      }
      Console.WriteLine("\nFirst：" + it.first().ToString());
  /*
  	执行结果：
      聚合的内容有：
      中山大学
      华南理工
      韶关学院
  
      First：中山大学
  */
  ```

  ##### 3.模式的应用实例

  【例1】用迭代器模式编写一个浏览婺源旅游风景图的程序。

  分析：婺源的名胜古迹较多，要设计一个查看相关景点图片（[点此下载本实例所要显示的景点图片](http://c.biancheng.net/uploads/soft/181113/3-1Q1161Q640.zip)）和简介的程序，用“迭代器模式”设计比较合适。

  首先，设计一个婺源景点（WyViewSpot）类来保存每张图片的名称与简介；再设计一个景点集（ViewSpotSet）接口，它是抽象聚合类，提供了增加和删除婺源景点的方法，以及获取迭代器的方法。

  然后，定义一个婺源景点集（WyViewSpotSet）类，它是具体聚合类，用 ArrayList 来保存所有景点信息，并实现父类中的抽象方法；再定义婺源景点的抽象迭代器（ViewSpotltemtor）接口，其中包含了查看景点信息的相关方法。

  最后，定义婺源景点的具体迭代器（WyViewSpotlterator）类，它实现了父类的抽象方法；客户端程序设计成窗口程序，它初始化婺源景点集（ViewSpotSet）中的数据，并实现 ActionListener 接口，它通过婺源景点迭代器（ViewSpotlterator）来査看婺源景点（WyViewSpot）的信息。图 2 所示是其结构图。

  ![image-20220427144323033](GOF 23种设计模式.assets\image-20220427144323033.png)

- #### 模式的扩展

  迭代器模式常常与[组合模式](http://c.biancheng.net/view/1373.html)结合起来使用，在对组合模式中的容器构件进行访问时，经常将迭代器潜藏在组合模式的容器构成类中。当然，也可以构造一个外部迭代器来对容器构件进行访问，其结构图如图 4 所示。
  
  ![image-20220427144405196](GOF 23种设计模式.assets\image-20220427144405196.png)
  
  

### 9.访问者模式（Visitor）

- #### Intro 简介

  在现实生活中，有些集合对象存在多种不同的元素，且每种元素也存在多种不同的访问者和处理方式。例如，公园中存在多个景点，也存在多个游客，不同的游客对同一个景点的评价可能不同；医院医生开的处方单中包含多种药元素，査看它的划价员和药房工作人员对它的处理方式也不同，划价员根据处方单上面的药品名和数量进行划价，药房工作人员根据处方单的内容进行抓药。

  这样的例子还有很多，例如，电影或电视剧中的人物角色，不同的观众对他们的评价也不同；还有顾客在商场购物时放在“购物车”中的商品，顾客主要关心所选商品的性价比，而收银员关心的是商品的价格和数量。

  这些被处理的数据元素相对稳定而访问方式多种多样的[数据结构](http://c.biancheng.net/data_structure/)，如果用“访问者模式”来处理比较方便。访问者模式能把处理方法从数据结构中分离出来，并可以根据需要增加新的处理方法，且不用修改原来的程序代码与数据结构，这提高了程序的扩展性和灵活性。

- #### 模式的定义与特点

  访问者（Visitor）模式的定义：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。

  访问者（Visitor）模式是一种对象行为型模式，其主要优点如下。

  1. 扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。
  2. 复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。
  3. 灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。
  4. 符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。

  访问者（Visitor）模式的主要缺点如下。

  1. 增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。
  2. 破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。
  3. 违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。

- #### 模式的应用场景

  当系统中存在类型数量稳定（固定）的一类数据结构时，可以使用访问者模式方便地实现对该类型所有数据结构的不同操作，而又不会对数据产生任何副作用（脏数据）。

  简而言之，就是当对集合中的不同类型数据（类型数量稳定）进行多种操作时，使用访问者模式。

  通常在以下情况可以考虑使用访问者（Visitor）模式。

  1. 对象结构相对稳定，但其操作算法经常变化的程序。
  2. 对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。
  3. 对象结构包含很多类型的对象，希望对这些对象实施一些依赖于其具体类型的操作。

- #### 模式的结构与实现

  访问者（Visitor）模式实现的关键是如何将作用于元素的操作分离出来封装成独立的类，其基本结构与实现方法如下。

  ##### 1. 模式的结构

  访问者模式包含以下主要角色。

  1. 抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。
  2. 具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。
  3. 抽象元素（Element）角色：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。
  4. 具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。
  5. 对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。

  其结构图如图 1 所示。

  ![image-20220427144545910](GOF 23种设计模式.assets\image-20220427144545910.png)

  ##### 2. 模式的实现

  模式的实现代码如下：

  ```c#
  namespace VisitorPattern;
  
  #region Visitor
  //抽象访问者
  internal abstract class Visitor
  {
      public abstract void VisitConcreteElementA(ConcreteElementA element);
  
      public abstract void VisitConcreteElementB(ConcreteElementB element);
  }
  //具体访问者A类
  internal class ConcreteVisitorA : Visitor
  {
      public override void VisitConcreteElementA(ConcreteElementA element)
      {
          Console.WriteLine($"{element.GetType().Name} 被 {GetType().Name} 访问");
          Console.WriteLine("具体访问者A访问-->" + element.OperationA());
      }
  
      public override void VisitConcreteElementB(ConcreteElementB element)
      {
          Console.WriteLine($"{element.GetType().Name} 被 {GetType().Name} 访问");
          Console.WriteLine("具体访问者A访问-->" + element.OperationB());
      }
  }
  //具体访问者B类
  internal class ConcreteVisitorB : Visitor
  {
      public override void VisitConcreteElementA(ConcreteElementA element)
      {
          Console.WriteLine($"{element.GetType().Name} 被 {GetType().Name} 访问");
          Console.WriteLine("具体访问者B访问-->" + element.OperationA());
      }
  
      public override void VisitConcreteElementB(ConcreteElementB element)
      {
          Console.WriteLine($"{element.GetType().Name} 被 {GetType().Name} 访问");
          Console.WriteLine("具体访问者B访问-->" + element.OperationB());
      }
  }
  #endregion Visitor
  
      
  #region Element
  //抽象元素类
  internal abstract class Element
  {
      public abstract void Accept(Visitor visitor);
  }
  //具体元素A类
  internal class ConcreteElementA : Element
  {
      public override void Accept(Visitor visitor)
      {
          visitor.VisitConcreteElementA(this);
      }
  
      public string OperationA()
      {
          return "具体元素A的操作。";
      }
  }
  //具体元素B类
  internal class ConcreteElementB : Element
  {
      public override void Accept(Visitor visitor)
      {
          visitor.VisitConcreteElementB(this);
      }
  
      public string OperationB()
      {
          return "具体元素B的操作。";
      }
  }
  #endregion Element
  
      
  //对象结构角色
  internal class ObjectStructure
  {
      private readonly IList<Element> _elements = new List<Element>();
  
      public void Attach(Element element)
      {
          _elements.Add(element);
      }
  
      public void Detach(Element element)
      {
          _elements.Remove(element);
      }
  
      public void Accept(Visitor visitor)
      {
          foreach (var element in _elements)
          {
              element.Accept(visitor);
          }
      }
  }
  
  /** Program.cs **/
      ObjectStructure os = new ObjectStructure();
      os.Attach(new ConcreteElementA());
      os.Attach(new ConcreteElementB());
  
      Visitor visitor = new ConcreteVisitorA();
      os.Accept(visitor);
      Console.WriteLine("------------------------");
      visitor = new ConcreteVisitorB();
      os.Accept(visitor);
  /*
  	执行结果：
      ConcreteElementA 被 ConcreteVisitorA 访问
      具体访问者A访问-->具体元素A的操作。
      ConcreteElementB 被 ConcreteVisitorA 访问
      具体访问者A访问-->具体元素B的操作。
      ------------------------
      ConcreteElementA 被 ConcreteVisitorB 访问
      具体访问者B访问-->具体元素A的操作。
      ConcreteElementB 被 ConcreteVisitorB 访问
      具体访问者B访问-->具体元素B的操作。
  */
  ```

  ##### 3.模式的应用实例

  【例1】利用“访问者（Visitor）模式”模拟艺术公司与造币公司的功能。

  分析：艺术公司利用“铜”可以设计出铜像，利用“纸”可以画出图画；造币公司利用“铜”可以印出铜币，利用“纸”可以印出纸币（[点此下载运行该程序后所要显示的图片](http://c.biancheng.net/uploads/soft/181113/3-1Q119103045.zip)）。对“铜”和“纸”这两种元素，两个公司的处理方法不同，所以该实例用访问者模式来实现比较适合。

  首先，定义一个公司（Company）接口，它是抽象访问者，提供了两个根据纸（Paper）或铜（Cuprum）这两种元素创建作品的方法；再定义艺术公司（ArtCompany）类和造币公司（Mint）类，它们是具体访问者，实现了父接口的方法。

  然后，定义一个材料（Material）接口，它是抽象元素，提供了 accept（Company visitor）方法来接受访问者（Company）对象访问；再定义纸（Paper）类和铜（Cuprum）类，它们是具体元素类，实现了父接口中的方法。

  最后，定义一个材料集（SetMaterial）类，它是对象结构角色，拥有保存所有元素的容器 List，并提供让访问者对象遍历容器中的所有元素的 accept（Company visitor）方法；客户类设计成窗体程序，它提供材料集（SetMaterial）对象供访问者（Company）对象访问，实现了 ItemListener 接口，处理用户的事件请求。图 2 所示是其结构图。

  ![image-20220427144622191](GOF 23种设计模式.assets\image-20220427144622191.png)

- #### 模式的扩展

  访问者（Visitor）模式是使用频率较高的一种[设计模式](http://c.biancheng.net/design_pattern/)，它常常同以下两种设计模式联用。

  (1)与“[迭代器模式](http://c.biancheng.net/view/1395.html)”联用。因为访问者模式中的“对象结构”是一个包含元素角色的容器，当访问者遍历容器中的所有元素时，常常要用迭代器。如【例1】中的对象结构是用 List 实现的，它通过 List 对象的 Iterator() 方法获取迭代器。如果对象结构中的聚合类没有提供迭代器，也可以用迭代器模式自定义一个。

  (2)访问者（Visitor）模式同“[组合模式](http://c.biancheng.net/view/1373.html)”联用。因为访问者（Visitor）模式中的“元素对象”可能是叶子对象或者是容器对象，如果元素对象包含容器对象，就必须用到[组合模式](http://c.biancheng.net/view/1373.html)，其结构图如图 4 所示。

  ![image-20220427144659049](GOF 23种设计模式.assets\image-20220427144659049.png)



### 10.备忘录模式（Memento）

- #### Intro 简介

  每个人都有犯错误的时候，都希望有种“后悔药”能弥补自己的过失，让自己重新开始，但现实是残酷的。在计算机应用中，客户同样会常常犯错误，能否提供“后悔药”给他们呢？当然是可以的，而且是有必要的。这个功能由“备忘录模式”来实现。

  其实很多应用软件都提供了这项功能，如 Word、记事本、Photoshop、Eclipse 等软件在编辑时按 Ctrl+Z 组合键时能撤销当前操作，使文档恢复到之前的状态；还有在 IE 中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。

  备忘录模式能记录一个对象的内部状态，当用户后悔时能撤销当前操作，使数据恢复到它原先的状态。

- #### 模式的定义与特点

  备忘录（Memento）模式的定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。

  备忘录模式是一种对象行为型模式，其主要优点如下。

  - 提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。
  - 实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。
  - 简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。


  其主要缺点是：资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。

- #### 模式的应用场景

  前面学习了备忘录模式的定义与特点、结构与实现，现在来看该模式的以下应用场景。

  1. 需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。
  2. 需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，Eclipse 等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。

- #### 模式的结构与实现

  备忘录模式的核心是设计备忘录类以及用于管理备忘录的管理者类，现在我们来学习其结构与实现。

  ##### 1. 模式的结构

  备忘录模式的主要角色如下。

  1. 发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。
  2. 备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。
  3. 管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。

  备忘录模式的结构图如图 1 所示。

  ![image-20220427144811161](GOF 23种设计模式.assets\image-20220427144811161.png)

  ##### 2. 模式的实现

  模式的实现代码如下：

  ```c#
  namespace MementoPattern;
  
  /// <summary>
  /// 备忘录
  /// </summary>
  internal class Memento
  {
      public string State { get; }
  
      public Memento(string state) => State = state;
  }
  /// <summary>
  /// 发起人
  /// </summary>
  internal class Originator
  {
      public string State { get; set; }
  
      public Memento CreateMemento()
      {
          return new Memento(State);
      }
  
      public void restoreMemento(Memento memento)
      {
          State = memento?.State;
      }
  
      public void Show()
      {
          Console.WriteLine($"State:{State}");
      }
  }
  /// <summary>
  /// 管理者
  /// </summary>
  internal class Caretaker
  {
      public Memento Memento { get; set; }
  }
  
  /** Program.cs **/
  {
      var originator = new Originator
      {
          State = "On"
      };
      originator.Show();
  
      var caretaker = new Caretaker
      {
          Memento = originator.CreateMemento()
      };
  
      originator.State = "Off";
      originator.Show();
  
      originator.restoreMemento(caretaker.Memento);
      originator.Show();
  
      Console.WriteLine();
  }
  {
      Originator or = new Originator();
      Caretaker cr = new Caretaker();
      or.State = "S0";
      Console.WriteLine("初始状态:" + or.State);
      cr.Memento = or.CreateMemento(); //保存状态
      or.State = "S1";
      Console.WriteLine("新的状态:" + or.State);
      or.restoreMemento(cr.Memento); //恢复状态
      Console.WriteLine("恢复状态:" + or.State);
  
      Console.WriteLine();
  }
  /*
  	执行结果：
      State:On
      State:Off
      State:On
  
      初始状态:S0
      新的状态:S1
      恢复状态:S0
  */
  ```

  ##### 3.模式的应用实例

  【例1】利用备忘录模式设计相亲游戏。

  分析：假如有西施、王昭君、貂蝉、杨玉环四大美女同你相亲，你可以选择其中一位作为你的爱人；当然，如果你对前面的选择不满意，还可以重新选择，但希望你不要太花心；这个游戏提供后悔功能，用“备忘录模式”设计比较合适（[点此下载所要显示的四大美女的图片](http://c.biancheng.net/uploads/soft/181113/3-1Q119131144.zip)）。

  首先，先设计一个美女（Girl）类，它是备忘录角色，提供了获取和存储美女信息的功能；然后，设计一个相亲者（You）类，它是发起人角色，它记录当前时刻的内部状态信息（临时妻子的姓名），并提供创建备忘录和恢复备忘录数据的功能；最后，定义一个美女栈（GirlStack）类，它是管理者角色，负责对备忘录进行管理，用于保存相亲者（You）前面选过的美女信息，不过最多只能保存 4 个，提供后悔功能。

  客户类设计成窗体程序，它包含美女栈（GirlStack）对象和相亲者（You）对象，它实现了 ActionListener 接口的事件处理方法 actionPerformed(ActionEvent e)，并将 4 大美女图像和相亲者（You）选择的美女图像在窗体中显示出来。图 2 所示是其结构图。

  ![image-20220427144839511](GOF 23种设计模式.assets\image-20220427144839511.png)

- #### 模式的扩展

  在前面介绍的备忘录模式中，有单状态备份的例子，也有多状态备份的例子。下面介绍备忘录模式如何同[原型模式](http://c.biancheng.net/view/1343.html)混合使用。在备忘录模式中，通过定义“备忘录”来备份“发起人”的信息，而原型模式的 clone() 方法具有自备份功能，所以，如果让发起人实现 Cloneable 接口就有备份自己的功能，这时可以删除备忘录类，其结构图如图 4 所示。
  
  ![image-20220427144905372](GOF 23种设计模式.assets\image-20220427144905372.png)
  
  #### 拓展
  
  由于 JDK、[Spring](http://c.biancheng.net/spring/)、[Mybatis](http://c.biancheng.net/mybatis/) 中很少有备忘录模式，所以该[设计模式](http://c.biancheng.net/design_pattern/)不做典型应用源码分析。
  
  Spring Webflow 中 DefaultMessageContext 类实现了 StateManageableMessageContext 接口，查看其源码可以发现其主要逻辑就相当于给 Message 备份。感兴趣的小伙伴可以去阅读学习其源码。
  
  

### 11.解释器模式（Interpreter）

- #### Intro 简介

  在软件开发中，会遇到有些问题多次重复出现，而且有一定的相似性和规律性。如果将它们归纳成一种简单的语言，那么这些问题实例将是该语言的一些句子，这样就可以用“编译原理”中的解释器模式来实现了。

  虽然使用解释器模式的实例不是很多，但对于满足以上特点，且对运行效率要求不是很高的应用实例，如果用解释器模式来实现，其效果是非常好的，本文将介绍其工作原理与使用方法。

- #### 模式的定义与特点

  解释器（Interpreter）模式的定义：给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。

  这里提到的文法和句子的概念同编译原理中的描述相同，“文法”指语言的语法规则，而“句子”是语言集中的元素。例如，汉语中的句子有很多，“我是中国人”是其中的一个句子，可以用一棵语法树来直观地描述语言中的句子。

  解释器模式是一种类行为型模式，其主要优点如下。

  1. 扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。
  2. 容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。

  解释器模式的主要缺点如下。

  1. 执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。
  2. 会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。
  3. 可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。

- #### 模式的应用场景

  前面介绍了解释器模式的结构与特点，下面分析它的应用场景。

  1. 当语言的文法较为简单，且执行效率不是关键问题时。
  2. 当问题重复出现，且可以用一种简单的语言来进行表达时。
  3. 当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候，如 XML 文档解释。

  注意：解释器模式在实际的软件开发中使用比较少，因为它会引起效率、性能以及维护等问题。如果碰到对表达式的解释，在 [Java](http://c.biancheng.net/java/) 中可以用 Expression4J 或 Jep 等来设计。

- #### 模式的结构与实现

  解释器模式常用于对简单语言的编译或分析实例中，为了掌握好它的结构与实现，必须先了解编译原理中的“文法、句子、语法树”等相关概念。

  **1) 文法**

  文法是用于描述语言的语法结构的形式规则。没有规矩不成方圆，例如，有些人认为完美爱情的准则是“相互吸引、感情专一、任何一方都没有恋爱经历”，虽然最后一条准则较苛刻，但任何事情都要有规则，语言也一样，不管它是机器语言还是自然语言，都有它自己的文法规则。例如，中文中的“句子”的文法如下。

  ```
  〈句子〉::=〈主语〉〈谓语〉〈宾语〉
  〈主语〉::=〈代词〉|〈名词〉
  〈谓语〉::=〈动词〉
  〈宾语〉::=〈代词〉|〈名词〉
  〈代词〉你|我|他
  〈名词〉7大学生I筱霞I英语
  〈动词〉::=是|学习
  注：这里的符号“::=”表示“定义为”的意思，用“〈”和“〉”括住的是非终结符，没有括住的是终结符。
  ```

  **2) 句子**

  句子是语言的基本单位，是语言集中的一个元素，它由终结符构成，能由“文法”推导出。例如，上述文法可以推出“我是大学生”，所以它是句子。

  **3) 语法树**

  语法树是句子结构的一种树型表示，它代表了句子的推导结果，它有利于理解句子语法结构的层次。图 1 所示是“我是大学生”的语法树。

  ![image-20220427145143625](GOF 23种设计模式.assets\image-20220427145143625.png)

  有了以上基础知识，现在来介绍解释器模式的结构就简单了。解释器模式的结构与[组合模式](http://c.biancheng.net/view/1373.html)相似，不过其包含的组成元素比组合模式多，而且组合模式是对象结构型模式，而解释器模式是类行为型模式。

  ##### 1. 模式的结构

  解释器模式包含以下主要角色。

  1. 抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。
  2. 终结符表达式（Terminal Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。
  3. 非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。
  4. 环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。
  5. 客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。

  解释器模式的结构图如图 2 所示。

  ![image-20220427145214559](GOF 23种设计模式.assets\image-20220427145214559.png)

  ##### 2. 模式的实现

  解释器模式实现的关键是定义文法规则、设计终结符类与非终结符类、画出结构图，必要时构建语法树，其代码结构如下：

  ```c#
  namespace InterpreterPattern;
  
  //抽象表达式类
  internal abstract class AbstractExpression
  {
      public abstract void Interpret(Context context); //解释方法
  }
  //终结符表达式类
  internal class TerminalExpression : AbstractExpression
  {
      public override void Interpret(Context context)
      {
          Console.WriteLine("TerminalExpressionInterpreter");
      }
  }
  //非终结符表达式类
  internal class NoneTerminalExpression : AbstractExpression
  {
      public override void Interpret(Context context)
      {
          Console.WriteLine("NonTerminalExpressionInterpreter");
      }
  }
  //环境类
  internal class Context
  {
      //public string Input { get; set; }
      //public string Output { get; set; }
  
      public Context()
      {
          //数据初始化
      }
      public void operation(String info)
      {
          //调用相关表达式类的解释方法
      }
  }
  
  /** Program.cs **/
  var context = new Context();
  ICollection<AbstractExpression> expressions = new List<AbstractExpression>();
  
  expressions.Add(new TerminalExpression());
  expressions.Add(new TerminalExpression());
  expressions.Add(new NoneTerminalExpression());
  
  foreach (var expression in expressions)
  {
      expression.Interpret(context);
  }
  /*
  	执行结果：
      TerminalExpressionInterpreter
      TerminalExpressionInterpreter
      NonTerminalExpressionInterpreter
  */
  ```

  ##### 3.模式的应用实例

  【例1】用解释器模式设计一个“韶粵通”公交车卡的读卡器程序。

  说明：假如“韶粵通”公交车读卡器可以判断乘客的身份，如果是“韶关”或者“广州”的“老人” “妇女”“儿童”就可以免费乘车，其他人员乘车一次扣 2 元。

  分析：本实例用“解释器模式”设计比较适合，首先设计其文法规则如下。

  ```
  <expression> ::= <city>的<person>
  <city> ::= 韶关|广州
  <person> ::= 老人|妇女|儿童
  ```

  然后，根据文法规则按以下步骤设计公交车卡的读卡器程序的类图。

  - 定义一个抽象表达式（Expression）接口，它包含了解释方法 interpret(String info)。
  - 定义一个终结符表达式（Terminal Expression）类，它用集合（Set）类来保存满足条件的城市或人，并实现抽象表达式接口中的解释方法 interpret(Stringinfo)，用来判断被分析的字符串是否是集合中的终结符。
  - 定义一个非终结符表达式（AndExpressicm）类，它也是抽象表达式的子类，它包含满足条件的城市的终结符表达式对象和满足条件的人员的终结符表达式对象，并实现 interpret(String info) 方法，用来判断被分析的字符串是否是满足条件的城市中的满足条件的人员。
  - 最后，定义一个环境（Context）类，它包含解释器需要的数据，完成对终结符表达式的初始化，并定义一个方法 freeRide(String info) 调用表达式对象的解释方法来对被分析的字符串进行解释。其结构图如图 3 所示。

  ![image-20220427145315702](GOF 23种设计模式.assets\image-20220427145315702.png)

- #### 模式的扩展

  在项目开发中，如果要对数据表达式进行分析与计算，无须再用解释器模式进行设计了，Java 提供了以下强大的数学公式解析器：Expression4J、MESP(Math Expression String Parser) 和 Jep 等，它们可以解释一些复杂的文法，功能强大，使用简单。

  现在以 Jep 为例来介绍该工具包的使用方法。Jep 是 Java expression parser 的简称，即 Java 表达式分析器，它是一个用来转换和计算数学表达式的 Java 库。通过这个程序库，用户可以以字符串的形式输入一个任意的公式，然后快速地计算出其结果。而且 Jep 支持用户自定义变量、常量和函数，它包括许多常用的数学函数和常量。

  使用前先下载 Jep 压缩包，解压后，将 jep-x.x.x.jar 文件移到选择的目录中，在 Eclipse 的“Java 构建路径”对话框的“库”选项卡中选择“添加外部 JAR(X)...”，将该 Jep 包添加项目中后即可使用其中的类库。

  下面以计算存款利息为例来介绍。存款利息的计算公式是：本金x利率x时间=利息，其相关代码如下：