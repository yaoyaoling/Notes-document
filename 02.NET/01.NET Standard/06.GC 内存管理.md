# 一、托管

​		.Net所指的托管资源到底是什么意思呢？是相对于所有资源，还是只限于某一方面的资源？很多人对此不是很了解。

​		其实.Net所指的托管只是针对内存这一个方面，并不是对于所有的元素；因此对于Stream，数据库的连接GDI+的相关对象，还有Com对象等等，这些资源并不是受到.Net管理而统称为非托管资源。而对于内存的释放和回收，系统提供了GC(Garbage Collector)，而至于其他资源则需要手动进行释放。

# 二、垃圾

​		什么是垃圾。.Net类型分为两大类，一个就是值类型，另一个就是引用类型。**前者是分配在栈上，并不需要GC回收**；**后者是分配在堆上，因此它的内存释放和回收需要通过GC来完成**。GC的全程为"Garbage Collector",顾名思义就是垃圾回收器，那么只有被称为垃圾的对象才能被GC回收。也就是说，一个引用类型对象所占的内存需要被GC回收，而满足回收的条件，首先就要需要称为垃圾。那么.Net如果判定一个引用类型对象是垃圾呢，.Net的判断很简单，只要判定此对象或者其包含的子对象没有任何引用是有效的，那么系统就认为它是垃圾。

# 三、GC运作方式

​		明确了基本概念，接下来就说说GC的运作方式以及GC的功能，内存的释放和回收需要伴随着程序的运行，因此系统为GC安排了独立的线程。那么GC的工作大致是，查询内存中对象是否成为垃圾，然后对垃圾进行释放和回收。那么对于GC对于内存回收采取了一定的有限算法进行轮询回收内存资源。其次，对于内存中的垃圾分为两种，一种需要调用对象的析构函数，另一种是不需要调用的。GC对于前者(需要调用析构函数的)的回收需要通过两步完成，第一步是调用对象的析构函数，第二步是回收内存，但是要注意这两步不是在GC一次轮询完成，即需要两次轮询；相对于后者(不需要调用析构函数的)，则只是回收内存而已。

​		对于某个具体的资源，是无法确切知道对象析构函数什么时候被调用的，以及GC什么时候会去释放和回收它所占用的内存。那么对于C、C++之类语言转换过来的程序员来说，这里需要转变观念。

​		对于程序资源来说，我们应该做些什么，以及如何去做，才能使程序效率最高，同时占用资源能尽快的释放。前面说过托管资源分两种，托管的内存资源，这是不需要我们操心的，系统已经为我们进行管理了，那么**对于非托管资源**，这里再重申一下，这就是Stream，数据库的连接，GDI+的相关对象，还有Com的相关对象，还有Com对象等等这些资源，需要我们手动去释放。

​	如何去释放，应该把这些操作放到哪里比较好呢。**.Net提供可三种方法，也是最常见的三种**，大致如下

1. 析构函数
2. 继承IDisposable接口，实现Dispose方法；

3. 提供Close方法。

​		经过前面的介绍，可以知道析构函数只能被GC来调用，那么无法确定它什么时候被调用，因此用它作为资源的释放并不是很合理，因为资源释放不及时；但是为了防止资源泄露，毕竟它会被GC调用，因此析构函数可以作为一个补救方法。

​		而Close与Dispose这两种方法的区别在于，调用完了对象的Close方法后，此对象有可能被重新进行使用；而Dispose方法来说，此对象所占用的资源需要被标记无用了，也就是此对象被销毁了，等待GC回收，不能再被使用。

​		例如，常见SqlConnection这个类，当调用完Close方法后，可以通过Open重新打开数据库连接，当彻底不用这个对象了就可以调用Dispose方法来标记此对象无用，等待GC回收。明白了这两种方法的意思后，大家在往自己的类中添加的接口时候，不要歪曲了这两者意思。



**注意事项：**析构函数只能由垃圾回收器调用。Despose()方法只能由类的使用者调用。在C#中，凡是继承了IDisposable接口的类，都可以使用using语句，从而在超出作用域后，让系统自动调用Dispose()方法。一个资源安全的类，都实现了IDisposable接口和析构函数。提供手动释放资源和系统自动释放资源的双保险。